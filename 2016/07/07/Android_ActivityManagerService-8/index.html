<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android6.0之AMS启动app中篇之创建app进程 | 码农故事</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前面分析到了ActivityStackSupervisor类中的startActivityUncheckedLocked方法,该方法主要是为要启动的activity准备一个task:有可复用的task,就直接使用;没有的话,就先寻找一个合适的ActivityStack,移动到前台后创建一个新的Task.紧接着调用ActivityStack的startActivityLocked()方法继续启动.">
<meta property="og:type" content="article">
<meta property="og:title" content="Android6.0之AMS启动app中篇之创建app进程">
<meta property="og:url" content="http://www.iloveandroid.net/2016/07/07/Android_ActivityManagerService-8/index.html">
<meta property="og:site_name" content="码农故事">
<meta property="og:description" content="前面分析到了ActivityStackSupervisor类中的startActivityUncheckedLocked方法,该方法主要是为要启动的activity准备一个task:有可复用的task,就直接使用;没有的话,就先寻找一个合适的ActivityStack,移动到前台后创建一个新的Task.紧接着调用ActivityStack的startActivityLocked()方法继续启动.">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-17.png">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-18.png">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-19.png">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-20.png">
<meta property="og:updated_time" content="2016-07-22T12:29:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android6.0之AMS启动app中篇之创建app进程">
<meta name="twitter:description" content="前面分析到了ActivityStackSupervisor类中的startActivityUncheckedLocked方法,该方法主要是为要启动的activity准备一个task:有可复用的task,就直接使用;没有的话,就先寻找一个合适的ActivityStack,移动到前台后创建一个新的Task.紧接着调用ActivityStack的startActivityLocked()方法继续启动.">
  
    <link rel="alternative" href="/atom.xml" title="码农故事" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">genglei.cuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不断成长的见证</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/linux基础">linux基础</a></li>
				        
							<li><a href="/categories/Android底层开发">Android底层开发</a></li>
				        
							<li><a href="/categories/App开发">App开发</a></li>
				        
							<li><a href="/categories/项目管理">项目管理</a></li>
				        
							<li><a href="/categories/Python">Python</a></li>
				        
							<li><a href="/categories/开源框架">开源框架</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android刷机/" style="font-size: 10px;">Android刷机</a> <a href="/tags/Android底层/" style="font-size: 10px;">Android底层</a> <a href="/tags/Android核心服务/" style="font-size: 20px;">Android核心服务</a> <a href="/tags/Android编译/" style="font-size: 11.43px;">Android编译</a> <a href="/tags/Gradle/" style="font-size: 15.71px;">Gradle</a> <a href="/tags/linux常用命令/" style="font-size: 10px;">linux常用命令</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/代码管理/" style="font-size: 18.57px;">代码管理</a> <a href="/tags/应用开发/" style="font-size: 10px;">应用开发</a> <a href="/tags/提高效率/" style="font-size: 10px;">提高效率</a> <a href="/tags/构建/" style="font-size: 15.71px;">构建</a> <a href="/tags/签名认证/" style="font-size: 11.43px;">签名认证</a> <a href="/tags/自动化测试/" style="font-size: 14.29px;">自动化测试</a> <a href="/tags/调试/" style="font-size: 12.86px;">调试</a> <a href="/tags/逆向工程/" style="font-size: 17.14px;">逆向工程</a> <a href="/tags/逆向开发/" style="font-size: 18.57px;">逆向开发</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">码农的成长之路，不要让昨日的悲伤，浪费今天的眼泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">genglei.cuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">genglei.cuan</h1>
			</hgroup>
			
			<p class="header-subtitle">不断成长的见证</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/linux基础">linux基础</a></li>
		        
					<li><a href="/categories/Android底层开发">Android底层开发</a></li>
		        
					<li><a href="/categories/App开发">App开发</a></li>
		        
					<li><a href="/categories/项目管理">项目管理</a></li>
		        
					<li><a href="/categories/Python">Python</a></li>
		        
					<li><a href="/categories/开源框架">开源框架</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Android_ActivityManagerService-8" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/07/Android_ActivityManagerService-8/" class="article-date">
  	<time datetime="2016-07-07T09:11:50.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android6.0之AMS启动app中篇之创建app进程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android核心服务/">Android核心服务</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android底层开发/">Android底层开发</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面分析到了ActivityStackSupervisor类中的startActivityUncheckedLocked方法,该方法主要是为要启动的activity准备一个task:有可复用的task,就直接使用;没有的话,就先寻找一个合适的ActivityStack,移动到前台后创建一个新的Task.紧接着调用ActivityStack的startActivityLocked()方法继续启动.</p>
<a id="more"></a>
<h3 id="ActivityStack的startActivityLocked()">ActivityStack的startActivityLocked()</h3><p>首先分析参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(</span><br><span class="line">ActivityRecord r, // 要启动的activity</span><br><span class="line"><span class="keyword">boolean</span> newTask,//是否新建了task,传入的<span class="keyword">true</span></span><br><span class="line"><span class="keyword">boolean</span> doResume,// 是否执行resume,传入的<span class="keyword">true</span></span><br><span class="line"><span class="keyword">boolean</span> keepCurTransition,// 传入的fasle,当要从一个activity启动一个activity,而且启动这个activity时,设置了FLAG_ACTIVITY_CLEAR_TOP,传入<span class="keyword">true</span></span><br><span class="line">Bundle options)</span></span></span><br></pre></td></tr></table></figure>
<p>如果是新创建的task,这个task已经在ActivityStack的顶端,而且其所在的Activitystack也在绑定的屏幕的顶端:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r.task就是在startActivityUncheckedLocked中创建的新的task的TaskRecord对象，取出来保存到rRask变量中</span></span><br><span class="line">TaskRecord rTask = r.task;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> taskId = rTask.taskId;</span><br><span class="line"><span class="comment">// 如果是新创建的task的话</span></span><br><span class="line"><span class="comment">// taskForIdLocked在历史栈中查询是否含有id号为目标类所在的栈id，如果有，表明目标类之前已经被创建过，现在开始复用该对象，属于非首次启动，</span></span><br><span class="line"><span class="comment">// newTask传递过来为true</span></span><br><span class="line"><span class="keyword">if</span> (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == <span class="keyword">null</span> || newTask)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其移到activitystack的顶部,也就是mTaskHistory的尾部</span></span><br><span class="line">    insertTaskAtTop(rTask, r);</span><br><span class="line">    mWindowManager.moveTaskToTop(taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要新创建task:(从launcher第一次启动app,会创建新的task,所以不走这块代码)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TaskRecord task = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!newTask) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> startIt = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 从 mTaskHistory中找到启动这个activity的activity所在的task</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">        task = mTaskHistory.get(taskNdx);</span><br><span class="line">        <span class="keyword">if</span> (task.getTopActivity() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// All activities in task are finishing.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">if</span> (task == r.task) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!startIt) &#123;</span><br><span class="line">                ............</span><br><span class="line">                ActivityOptions.abort(options);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">// 如果在前面的task中有全屏应用存在,例如播放器等,设置为false.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (task.numFullscreen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            startIt = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是从activitystack的mTaskHistory中找到启动这个activity的activity的task.</p>
<p>如果找到的这个task不在ActivityStack的顶端,那就没必要让当前正在显示的activity执行onUserLeaving操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">            mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,</span><br><span class="line">                    <span class="string">"startActivity() behind front, mUserLeaving=false"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着把要启动的activity放入Task的顶端,并设置inHistory为true;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task = r.task;</span><br><span class="line">task.addActivityToTop(r);</span><br><span class="line">task.setFrontOfTask();</span><br><span class="line">r.putInHistory();</span><br></pre></td></tr></table></figure>
<p>下面WMS开始准备绘制activity以及切换Activity时的动画.略过:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 一个activity的UI界面要想再终端屏幕上显示出来，很重要的一点就是他必须向WMS中添加token，以便于WMS在启动窗口的时候能够找到它</span></span><br><span class="line">  mWindowManager.addAppToken(task.mActivities.indexOf(r),</span><br><span class="line">                   r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                   (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != <span class="number">0</span>, r.userId,</span><br><span class="line">                   r.info.configChanges, task.voiceSession != <span class="keyword">null</span>, r.mLaunchTaskBehind);</span><br><span class="line">     <span class="keyword">boolean</span> doShow = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 处理FLAG_ACTIVITY_RESET_TASK_IF_NEEDED,rest  task</span></span><br><span class="line">             resetTaskIfNeededLocked(r, r);</span><br><span class="line">             <span class="comment">// 得到rest task之后,task的顶端activity是否与要启动的activity一致</span></span><br><span class="line">             doShow = topRunningNonDelayedActivityLocked(<span class="keyword">null</span>) == r;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> ActivityOptions(options).getAnimationType()</span><br><span class="line">             == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">         doShow = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中关键的一点是:当是新创建task的时候,此时这个task的affinity就是activity的taskAffinity.这个要启动activity就是这个task的root activity.</p>
<p>这时候如果flag中包含FLAG_ACTIVITY_RESET_TASK_IF_NEEDED,那么就会寻找当前activitystack中所有task中是设置了允许TaskReparenting,而又与其启动者没有依赖关系的activity(activity的resultTo为空),查看他们指定的task是不是现在这个新创建的task,是的话移动到这个新创建的task中来.</p>
<p>Task的startActivityLocked()方法主要就是将要启动的Activity加入到task的顶部.如果传入的newTask为true,表明创建了新的task,这是还要检查是否进行rest  task操作处理TaskReparenting;为false,表明没有创建task,而是将activity加入到启动他的activity所在的task中.然后把task调整到ActivityStack中的mTaskHistory的顶部.也就是将task移动到栈顶.然后调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的为true</span></span><br><span class="line"><span class="keyword">if</span> (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(<span class="keyword">this</span>, r, options);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>开始显示task顶部的activity(并不一定是要启动的activity).</p>
<h3 id="ActivityStackSupervisor-resumeTopActivitiesLocked()方法">ActivityStackSupervisor.resumeTopActivitiesLocked()方法</h3><p>这里要说明下,当从launcher,也就是桌面切换到一个app的activity的时候,前面也说了如果这个app所在的activitystack和homestack处于同一个屏幕中,就要调用ActivityStackSupervisor.moveHomeStack方法,来移动homestack.(确切的是当调用Activitystack.moveToFront()方法时,会进行这样的操作.)这时,mFocusedStack就会发生变化了,之前mFocusedStack是mhomeStack.在moveHomeStack方法会将其设置为即将显示的activity所在的ActivityStack.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivitiesLocked</span><span class="params">(ActivityStack targetStack, ActivityRecord target,</span><br><span class="line">          Bundle targetOptions)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果传入的ActivityStack为null,那么设置为当前处于前台的ActivityStack</span></span><br><span class="line">      <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">          targetStack = mFocusedStack;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Do targetStack first.</span></span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查targetStack是否和mFocusedStack一致.这里是一致的.原因前面解释了.</span></span><br><span class="line">      <span class="keyword">if</span> (isFrontStack(targetStack)) &#123;</span><br><span class="line">          result = targetStack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ............</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ActivityStack-resumeTopActivityLocked()方法">ActivityStack.resumeTopActivityLocked()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityLocked</span><span class="params">(ActivityRecord prev, Bundle options)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果当前正在resume顶端activity的话，那就直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">            mService.updateSleepIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用resumeTopActivityInnerLocked()方法</p>
<h3 id="ActivityStack-resumeTopActivityInnerLocked">ActivityStack.resumeTopActivityInnerLocked</h3><p>方法代码又是很多……….看注释吧!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, Bundle options)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (DEBUG_LOCKSCREEN) mService.logLockScreen(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">          <span class="comment">// Not ready yet!</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ActivityRecord parent = mActivityContainer.mParentActivity;</span><br><span class="line">      <span class="keyword">if</span> ((parent != <span class="keyword">null</span> &amp;&amp; parent.state != ActivityState.RESUMED) ||</span><br><span class="line">              !mActivityContainer.isAttachedLocked()) &#123;</span><br><span class="line">          <span class="comment">// Do not resume this stack if its parent is not resumed.</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> If in a loop, make sure that parent stack resumeTopActivity is called 1st.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这里的操作还是比较简单的，首先查看系统是否启动完成了，否则就直接返回。如果启动当前activity的activity本身的状态不是RESUMED的话，那么不能启动activity，直接返回false。</p>
<p>接下来找到,要启动的activity,这里实际上就是task的顶端activity.经过前面的过程,当前前台的task的就是运行要启动的activity所需的task.但至于顶端是否是要启动的activity那就不一定了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next就是要启动的activity</span></span><br><span class="line"><span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prevTask就是要启动的activity所在的task</span></span><br><span class="line"><span class="keyword">final</span> TaskRecord prevTask = prev != <span class="keyword">null</span> ? prev.task : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有要启动的activity,那就显示home</span></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">  ....</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要延时resume</span></span><br><span class="line">next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line"><span class="comment">// 如果显示的activity就是要启动的activity,那么直接返回false</span></span><br><span class="line"><span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp;</span><br><span class="line">          mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">  ............</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面又是做了一些检查而已</span></span><br><span class="line"><span class="comment">// 其中在创建task的时候</span></span><br><span class="line"><span class="comment">//  taskType = APPLICATION_ACTIVITY_TYPE;</span></span><br><span class="line"><span class="comment">//  mTaskToReturnTo = HOME_ACTIVITY_TYPE;</span></span><br><span class="line"><span class="comment">// 所以isOverHomeStack返回true</span></span><br><span class="line"><span class="keyword">if</span> (prevTask != <span class="keyword">null</span> &amp;&amp; prevTask.stack == <span class="keyword">this</span> &amp;&amp;</span><br><span class="line">      prevTask.isOverHomeStack() &amp;&amp; prev.finishing &amp;&amp; prev.frontOfTask) &#123;</span><br><span class="line">  <span class="keyword">if</span> (DEBUG_STACK)  mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">  <span class="comment">// 几乎都满足这个条件,而setFrontOfTask前面已经做过了</span></span><br><span class="line">  <span class="keyword">if</span> (prevTask == nextTask) &#123;</span><br><span class="line">      prevTask.setFrontOfTask();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevTask != topTask()) &#123;</span><br><span class="line">      <span class="comment">// This task is going away but it was supposed to return to the home stack.</span></span><br><span class="line">      <span class="comment">// Now the task above it has to return to the home task instead.</span></span><br><span class="line">      <span class="comment">// 如果task销毁了,移动到home</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> taskNdx = mTaskHistory.indexOf(prevTask) + <span class="number">1</span>;</span><br><span class="line">      mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isOnHomeDisplay()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isHomeStack())&#123;</span><br><span class="line">      ..............</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来还是做检查:如果系统当前准备休眠或者关机，如果是的话，那么就放弃本次启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are sleeping, and there is no resumed activity, and the top</span></span><br><span class="line"><span class="comment">// activity is paused, well that is the state we want.</span></span><br><span class="line"><span class="keyword">if</span> (mService.isSleepingOrShuttingDown()</span><br><span class="line">        &amp;&amp; mLastPausedActivity == next</span><br><span class="line">        &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">    <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">    <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">    mWindowManager.executeAppTransition();</span><br><span class="line">    mNoAnimActivities.clear();</span><br><span class="line">    ActivityOptions.abort(options);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">            <span class="string">"resumeTopActivityLocked: Going to sleep and all paused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是做检查,检查这个activity的用户已经启动了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line"><span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line"><span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line"><span class="keyword">if</span> (mService.mStartedUsers.get(next.userId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">  Slog.w(TAG, <span class="string">"Skipping resume of top activity "</span> + next</span><br><span class="line">          + <span class="string">": user "</span> + next.userId + <span class="string">" is stopped"</span>);</span><br><span class="line">  <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line"><span class="comment">// appropriate for it.</span></span><br><span class="line">mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">mStackSupervisor.mWaitingVisibleActivities.remove(next);</span><br></pre></td></tr></table></figure>
<p>如果当前启动的activity正在等待stop，那么就放弃stop直接启动。因为现在已经没有必要将它stop了。</p>
<p>如果我们当前正在pause一个activity，那么我们需要等到我们的pause动作完成了才能开始启动activity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We need to start pausing the current activity so the top one</span></span><br><span class="line">       <span class="comment">// can be resumed...</span></span><br><span class="line">       <span class="keyword">boolean</span> dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">       <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                   <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">           pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, <span class="keyword">true</span>, dontWaitForPause);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (pausing) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                   <span class="string">"resumeTopActivityLocked: Skip resume: need to start pausing"</span>);</span><br><span class="line">           <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">           <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">           <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">           <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">           <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>继续,如果activity所在的app进程已经启动,那么直接显示activity.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resume running: "</span> + next);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This activity is now becoming visible.</span></span><br><span class="line">            mWindowManager.setAppVisibility(next.appToken, <span class="keyword">true</span>);</span><br><span class="line">          ..........</span><br><span class="line">            mService.updateCpuStats();</span><br><span class="line">         ..........</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这个activity还有等待返回的结果,先发送结果</span></span><br><span class="line">                ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">                <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                    <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                                <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                        next.app.thread.scheduleSendResult(next.appToken, a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此时,说明要启动的activity已经存在,直接回调应用的onNewIntent方法</span></span><br><span class="line">                <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next.app.thread.scheduleNewIntent(next.newIntents, next.appToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              ............</span><br><span class="line">              <span class="comment">//调用activity的onResume</span></span><br><span class="line">                next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class="line">                        mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class="line"></span><br><span class="line">                mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span> + next);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ..............</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          .............</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// 如过activity所在的进程还没启动,那么就使用下面的方法启动app进程.</span></span><br><span class="line">          mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>resumeTopActivityInnerLocked()方法代码很长,检查的代码太多了,其实主要做了如下工作:</p>
<ol>
<li><p>如果要启动的activity所在的进程已经启动,那么调用应用的scheduleResumeActivity恢复activity即可(如果此activity已经存在,那么需要先scheduleNewIntent,也就是调用onNewIntent方法)</p>
</li>
<li><p>如果要启动的activity所在的app进程还没启动,那么调用mStackSupervisor.startSpecificActivityLocked启动app进程,第一次启动app时,符合这个逻辑.</p>
</li>
</ol>
<h3 id="ActivityStackSupervisor-startSpecificActivityLocked()方法">ActivityStackSupervisor.startSpecificActivityLocked()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次启动app时,肯定app进程还没启动</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">          .........</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用AMS的startProcessLocked创建成</span></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ActivityManagerService-startProcessLocked()方法">ActivityManagerService.startProcessLocked()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span><br><span class="line">          ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span><br><span class="line">          String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</span><br><span class="line">          <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">              hostingName, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">              <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">              <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用另一个同名不同参的startProcessLocked方法,介绍一下参数的含义.</p>
<p>processNam,即将要创建的在这个app进程的名字.传入的要启动的activity:ActivityRecord的processName.在创建ActivityRecord时,其构造方法中惠根据传入的要启动额activity的信息ActivityInfo记录的从清单xml文件中获得的进程名字,没有显示指定的话,默认为app的包名;</p>
<p>info要启动的app的ApplicationInfo,也是通过要启动的activity的ActivityInfo中获取的;</p>
<p>knownToBeDead传入的true;</p>
<p>intentFlags传入的0;</p>
<p>hostingType 传入的”activity”;</p>
<p>hostingName 传入的启动这个activity的intent设置的组件名,其实就是:app包名+app主actyivity的类名;</p>
<p>allowWhileBooting 传入的fasle;</p>
<p>isolated传入的false,说明要去检查当前进程列表中是否存在一个同名的进程,有的话复用这个进程.</p>
<p>keepIfLarge传入的false;</p>
<p>接下来的参数是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span><br><span class="line">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">        <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span><br><span class="line">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span></span></span><br></pre></td></tr></table></figure>
<p>多出来的:</p>
<p>isolatedUid 传入的 0;</p>
<p>abiOverride,entryPoint,entryPointArgs,crashHandler传入的均为null;</p>
<p>分析其代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span><br><span class="line">            <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">            <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span><br><span class="line">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        ProcessRecord app;</span><br><span class="line">  <span class="comment">// 传入的fale.那么要检查当前系统中是否存在同名进程,存在的话并不需要重新创建了,复用即可</span></span><br><span class="line">  <span class="comment">// 但要清除这个已经存在的进程的一些信息,比如crash的次数等.</span></span><br><span class="line">  <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">        ....</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      app = <span class="keyword">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">  <span class="comment">// 这里只考虑 app为null,也就是app进程没有被创建过</span></span><br><span class="line">  <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">      app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">      <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">          Slog.w(TAG, <span class="string">"Failed making new process record for "</span></span><br><span class="line">                  + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      app.crashHandler = crashHandler;</span><br><span class="line">      checkTime(startTime, <span class="string">"startProcess: done creating new process record"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">  <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>newProcessRecordLocked代码就是创建一个ProcessRecord对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess,</span><br><span class="line">           <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid)</span> </span>&#123;</span><br><span class="line">       String proc = customProcess != <span class="keyword">null</span> ? customProcess : info.processName;</span><br><span class="line">       BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.uid);</span><br><span class="line">       <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">       <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">          .........</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> ProcessRecord r = <span class="keyword">new</span> ProcessRecord(stats, info, proc, uid);</span><br><span class="line">       <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">               &amp;&amp; userId == UserHandle.USER_OWNER</span><br><span class="line">               &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">           r.persistent = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将即将要新创建的进程名字加入到AMS的mProcessNames中</span></span><br><span class="line">       addProcessNameLocked(r);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ProcessRecord是一个进程在AMS中的代表,也是AMS管理一个进程的数据结构,所以很有必要掌握其关键数据成员.</p>
<p>其构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord(BatteryStatsImpl _batteryStats, ApplicationInfo _info,</span><br><span class="line">        String _processName, <span class="keyword">int</span> _uid) &#123;</span><br><span class="line">    mBatteryStats = _batteryStats;</span><br><span class="line">    info = _info;</span><br><span class="line">    isolated = _info.uid != _uid;<span class="comment">//传入的两者相等,所以为fasle</span></span><br><span class="line">    uid = _uid;</span><br><span class="line">    userId = UserHandle.getUserId(_uid);</span><br><span class="line">    processName = _processName;</span><br><span class="line">    pkgList.put(_info.packageName, <span class="keyword">new</span> ProcessStats.ProcessStateHolder(_info.versionCode));</span><br><span class="line">    maxAdj = ProcessList.UNKNOWN_ADJ;</span><br><span class="line">    curRawAdj = setRawAdj = -<span class="number">100</span>;</span><br><span class="line">    curAdj = setAdj = -<span class="number">100</span>;</span><br><span class="line">    persistent = <span class="keyword">false</span>;</span><br><span class="line">    removed = <span class="keyword">false</span>;</span><br><span class="line">    lastStateTime = lastPssTime = nextPssTime = SystemClock.uptimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProcessRecord">ProcessRecord</h3><p>源码路径:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android-6/frameworks/base/services/core/java/com/android/server/am/ProcessRecord.java</span><br></pre></td></tr></table></figure>
<p>一个APK文件运行时会对应一个进程，当然，多个APK文件也可以运行在同一个进程中。ProcessRecord正是AMS记录一个进程中相关信息的类，该类中内部变量可分为三个部分:</p>
<h4 id="进程文件信息">进程文件信息</h4><p>也就是与该进程对应的APK文件的内部信息.比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationInfo info;</span><br><span class="line"></span><br><span class="line">String processName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存该进程中的所有APK文件包名</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;String, ProcessStats.ProcessStateHolder&gt; pkgList = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>其中ApplicationInfo类定义节选如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfo</span> <span class="keyword">extends</span> <span class="title">PackageItemInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String taskAffinity;<span class="comment">// 任务栈名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String permission;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String processName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String className;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="keyword">public</span> String sourceDir;</span><br><span class="line">..................</span><br><span class="line">   <span class="keyword">public</span> String[] resourceDirs;</span><br><span class="line">.....................</span><br><span class="line">   <span class="keyword">public</span> String[] sharedLibraryFiles;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String dataDir;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String nativeLibraryDir;</span><br><span class="line">   .....................</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String primaryCpuAbi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String secondaryCpuAbi;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> uid;</span><br><span class="line">  .............</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> targetSdkVersion;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> versionCode;</span><br></pre></td></tr></table></figure>
<h4 id="进程的内存状态信息">进程的内存状态信息</h4><p>这些信息将用于Linux系统的Out Of Memory(OOM)情况的处理，当发生系统内部不够用时，Linux系统会根据进程的内存状态信息，杀掉优先级比较低的进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxAdj;</span><br><span class="line"><span class="keyword">int</span> curAdj;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 是否是被AMS主动杀掉的，而不是因为内存不足而被杀掉</span></span><br><span class="line"><span class="keyword">boolean</span> killedByAm;         <span class="comment">// True when proc has been killed by activity manager, not for RAM</span></span><br><span class="line"><span class="comment">// 是否被杀掉</span></span><br><span class="line"><span class="keyword">boolean</span> killed;             <span class="comment">// True once we know the process has been killed</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>变量中adj的含义是adjustment，即“调整值”</p>
<h4 id="进程中包含的Activity,Provider,Service等">进程中包含的Activity,Provider,Service等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all activities running in the process</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; activities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// all ServiceRecord running in this process</span></span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;ServiceRecord&gt; services = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">// services that are currently executing code (need to remain foreground).</span></span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;ServiceRecord&gt; executingServices = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">// All ConnectionRecord this process holds</span></span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;ConnectionRecord&gt; connections = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">// all IIntentReceivers that are registered from this process.</span></span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;ReceiverList&gt; receivers = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">// class (String) -&gt; ContentProviderRecord</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;String, ContentProviderRecord&gt; pubProviders = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line"><span class="comment">// All ContentProviderRecord process is using</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ContentProviderConnection&gt; conProviders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="接着分析startProcessLocked">接着分析startProcessLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(</span><br><span class="line">            ProcessRecord app, //前面创建的ProcessRecord对象</span><br><span class="line">            String hostingType,// <span class="string">"activity"</span></span><br><span class="line">            String hostingNameStr, // <span class="string">"app包名+主activity类名"</span></span><br><span class="line">            String abiOverride,// <span class="keyword">null</span></span><br><span class="line">            String entryPoint,// <span class="keyword">null</span></span><br><span class="line">            String[] entryPointArgs)</span><span class="comment">// null</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法很重要,代码也比较短,直接分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚启动app时,pid为0,所以不满足条件</span></span><br><span class="line"><span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">....</span><br><span class="line"><span class="comment">// mProcessesOnHold记录的是系统为准备好时,就想运行的app,这里因为已经准备好了,所以从这里移除它</span></span><br><span class="line">mProcessesOnHold.remove(app);</span><br><span class="line"><span class="comment">//更新cpu状态</span></span><br><span class="line">updateCpuStats();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">  <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 该进程使用的外部存储</span></span><br><span class="line">  <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">  <span class="comment">// 通过前面传入ProcessRecord构造方法参数可知,其为false,所以执行</span></span><br><span class="line">  <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 得到pms</span></span><br><span class="line">      <span class="keyword">final</span> IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line">      <span class="comment">// 获取app拥有的权限组</span></span><br><span class="line">      permGids = pm.getPackageGids(app.info.packageName, app.userId);  </span><br><span class="line">      MountServiceInternal mountServiceInternal = LocalServices.getService(</span><br><span class="line">                           MountServiceInternal.class);</span><br><span class="line">       mountExternal = mountServiceInternal.getExternalStorageMountMode(uid,</span><br><span class="line">               app.info.packageName);</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Add shared application and profile GIDs so applications can share some</span><br><span class="line">     * resources like shared libraries and access user-wide resources</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(permGids)) &#123;</span><br><span class="line">        gids = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">2</span>, permGids.length);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">  gids[<span class="number">1</span>] = UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从ActivityInfo中提取给进程设置的相关标志,zygote创建新城时需要用到</span></span><br><span class="line">  <span class="keyword">int</span> debugFlags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;</span><br><span class="line">      <span class="comment">// Also turn on CheckJNI for debuggable apps. It's quite</span></span><br><span class="line">      <span class="comment">// awkward to turn on otherwise.</span></span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Run the app in safe mode if its manifest requests so or the</span></span><br><span class="line">  <span class="comment">// system is booted in safe mode.</span></span><br><span class="line">  <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_VM_SAFE_MODE) != <span class="number">0</span> ||</span><br><span class="line">      mSafeMode == <span class="keyword">true</span>) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.checkjni"</span>))) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</span><br><span class="line">  &#125;</span><br><span class="line">  String jitDebugProperty = SystemProperties.get(<span class="string">"debug.usejit"</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"true"</span>.equals(jitDebugProperty)) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_JIT;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">"false"</span>.equals(jitDebugProperty)) &#123;</span><br><span class="line">      <span class="comment">// If we didn't force disable by setting false, defer to the dalvik vm options.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"true"</span>.equals(SystemProperties.get(<span class="string">"dalvik.vm.usejit"</span>))) &#123;</span><br><span class="line">          debugFlags |= Zygote.DEBUG_ENABLE_JIT;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  String genDebugInfoProperty = SystemProperties.get(<span class="string">"debug.generate-debug-info"</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"true"</span>.equals(genDebugInfoProperty)) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.jni.logging"</span>))) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.assert"</span>))) &#123;</span><br><span class="line">      debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取进行运行时的abi,如:armeabi,armeabi-v7a等</span></span><br><span class="line">  <span class="comment">// 对于有so库的app来说,PMS会解析除这个变量</span></span><br><span class="line">  String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride : app.info.primaryCpuAbi;</span><br><span class="line">  <span class="comment">// 对于没有so库的app来说,设置为系统的主abi</span></span><br><span class="line">  <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置进程指令集,如arm,arm64,x86,mips等</span></span><br><span class="line">  String instructionSet = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (app.info.primaryCpuAbi != <span class="keyword">null</span>) &#123;</span><br><span class="line">      instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 墙面获取到的信息,填充到ProcessRecord中,</span></span><br><span class="line">  app.gids = gids;</span><br><span class="line">  app.requiredAbi = requiredAbi;</span><br><span class="line">  app.instructionSet = instructionSet;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置进程的入口点,也就是执行代码的入口点</span></span><br><span class="line">  <span class="comment">// 传入的为null,所以为true</span></span><br><span class="line">  <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 设置进程入口点</span></span><br><span class="line">  <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>)</span><br><span class="line">    entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line"></span><br><span class="line">		.......</span><br><span class="line">		<span class="comment">// 开始真正的创建进程</span></span><br><span class="line"> Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line"><span class="comment">// 创建app进程的时候为false</span></span><br><span class="line"><span class="keyword">if</span> (app.isolated) &#123;</span><br><span class="line">     mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 电源管理</span></span><br><span class="line">mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置该变量为true,表明该进程要一直存在,当被杀死时,要被重新唤醒.所以加入watchdog中</span></span><br><span class="line"><span class="comment">// 前面在创建这个ProcessRecord时设置的是fasle</span></span><br><span class="line"><span class="keyword">if</span> (app.persistent) &#123;</span><br><span class="line">		watchdog.getInstance().processStarted(app.processName, startResult.pid);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 继续初始化ProcessRecord,</span></span><br><span class="line">app.setPid(startResult.pid);<span class="comment">//前面创建进程时,返回了进程号pid</span></span><br><span class="line">app.usingWrapper = startResult.usingWrapper;</span><br><span class="line">app.removed = <span class="keyword">false</span>;</span><br><span class="line">app.killed = <span class="keyword">false</span>;</span><br><span class="line">app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line"><span class="keyword">this</span>.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line"><span class="comment">// 前面设置了该变量为true</span></span><br><span class="line"><span class="keyword">if</span> (isActivityProcess) &#123;</span><br><span class="line">		<span class="comment">// 向AMS发送PROC_START_TIMEOUT_MSG消息</span></span><br><span class="line">    Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = app;</span><br><span class="line">    mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">            ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startProcessLocked()方法的流程是:准备好启动进程的相关参数,例如进程权等,调用Process的start()方法来启动进程.启动进程后,利用返回的信息初始化ProcessRecord,比如拿到进程pid等.</p>
<p>启动进程之后,AMS给自己发送一个PROC_START_TIMEOUT_MSG消息,这个消息用来防止进程启动时间超时.如果start()方法返回结果中usingWrapper为true,超时时间设置为1200秒,否则设置为10秒.如果时间到了进程还没启动AMS将弹出ANR对话框.</p>
<p><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-17.png" alt=""></p>
<h3 id="Process-start()方法">Process.start()方法</h3><p>源码位置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android-6/frameworks/base/core/java/android/os/Process.java</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(</span><br><span class="line">                              <span class="keyword">final</span> String processClass,//进程的入口点,android.app.ActivityThread</span><br><span class="line">                              <span class="keyword">final</span> String niceName,//进程的名字</span><br><span class="line">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,// 进程uid gid,权限相关</span><br><span class="line">                              <span class="keyword">int</span> debugFlags, // app在清单文件中设置的进程相关标记 ,以及系统设置的进程标记,例如是否让VM执行checkjni等</span><br><span class="line">                              <span class="keyword">int</span> mountExternal,// 外部存储相关</span><br><span class="line">                              <span class="keyword">int</span> targetSdkVersion,// app中指定的targetSdkVersion</span><br><span class="line">                              String seInfo,//SElinux相关,设置进程安全上下文使用</span><br><span class="line">                              String abi,//进程abi,如armeabi,armeabi-v7a等</span><br><span class="line">                              String instructionSet,// 指令集.如arm,arm64,x86,mips等</span><br><span class="line">                              String appDataDir,//app数据沙箱目录</span><br><span class="line">                              String[] zygoteArgs //传入的为<span class="keyword">null</span></span><br><span class="line">                              )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Process类的startViaZygote方法里，会计算启动应用进程用的各个参数，然后再调用zygoteSendArgsAndGetResult方法将这些参数通过socket发送给zygote进程，zygote进程会孵化出新的dalvik应用进程，然后告诉ActivityManagerService新启动的进程的pid。</p>
<h3 id="Process-startViaZygote()方法">Process.startViaZygote()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span><br><span class="line">                              <span class="keyword">final</span> String niceName,</span><br><span class="line">                              <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span><br><span class="line">                              <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span><br><span class="line">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span><br><span class="line">                              <span class="keyword">int</span> targetSdkVersion,</span><br><span class="line">                              String seInfo,</span><br><span class="line">                              String abi,</span><br><span class="line">                              String instructionSet,</span><br><span class="line">                              String appDataDir,</span><br><span class="line">                              String[] extraArgs)</span></span><br><span class="line">                              <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">      ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      <span class="comment">// 开始整理传入的参数</span></span><br><span class="line">      argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">      argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">      argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">      <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != <span class="number">0</span>) &#123;</span><br><span class="line">         argsForZygote.add(<span class="string">"--enable-jni-logging"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      ..........</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">          argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">      &#125;</span><br><span class="line">      .....</span><br><span class="line">      argsForZygote.add(processClass);</span><br><span class="line">      <span class="comment">// 传入的为null</span></span><br><span class="line">     <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">             argsForZygote.add(arg);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将这些参数通过socket发送给zygote进程,用来创建进程</span></span><br><span class="line">     <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中openZygoteSocketIfNeeded()方法用来连接Zygote socket.从Android 5.0开始,Android开始支持64位系统.对于64位Android系统来说,存在两个zygote进程:</p>
<ol>
<li><p>主zygote,对应的socket:/dev/socket/zygote</p>
</li>
<li><p>次zygote,对应的scoket:/dev/socket/zygote_secondary</p>
</li>
</ol>
<p>至于主次zygote哪个对应于64位的zygote,哪个是32位的zygote.则有init进程解析相关rc文件决定.</p>
<p>连接zygote时,首先连接主zygote.主次zygote一个是64,一个是32,所以支持的abi肯定不同.根据当前的abi来选择与zygote32还是zygote64来进行通信。</p>
<p><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-18.png" alt=""></p>
<p>openZygoteSocketIfNeeded()方法返回值是ZygoteState对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZygoteState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LocalSocket socket;</span><br><span class="line">    <span class="keyword">final</span> DataInputStream inputStream;</span><br><span class="line">    <span class="keyword">final</span> BufferedWriter writer;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; abiList;</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
<h3 id="Process-zygoteSendArgsAndGetResult()方法">Process.zygoteSendArgsAndGetResult()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span><br><span class="line">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span><br><span class="line">            <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">            <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先发参数所占字节数大小</span></span><br><span class="line">            writer.write(Integer.toString(args.size()));</span><br><span class="line">            <span class="comment">// 开始新的一行(相当于发了"\n")</span></span><br><span class="line">            writer.newLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = args.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                String arg = args.get(i);</span><br><span class="line">                <span class="keyword">if</span> (arg.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(</span><br><span class="line">                            <span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送一个参数</span></span><br><span class="line">                writer.write(arg);</span><br><span class="line">                <span class="comment">// 开始新的一行(相当于发了"\n")</span></span><br><span class="line">                writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将信息发送给zygote</span></span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line">            <span class="comment">// 通过socket读取zygote的返回信息(阻塞到有数为止)</span></span><br><span class="line">            <span class="comment">// zygote先发送创建的进程的pid,为-1表示创建失败</span></span><br><span class="line">            result.pid = inputStream.readInt();</span><br><span class="line">            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 然后发送的是一个boolean值,于超时间的设定有关</span></span><br><span class="line">            result.usingWrapper = inputStream.readBoolean();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zygote孵化App进程">Zygote孵化App进程</h3><p>zygote进程将ZygoteInit作为启动类，会执行它的main方法，先注册Zygote Socket，然后调用runSelectLoop方法，runSelectLoop方法会调用方法在Zygote Socket上监听请求，如果别的进程通过Zygote Socket请求孵化进程，则孵化进程。</p>
<p>ZygoteInit.main:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runSelectLoop()方法会抛出异常MethodAndArgsCaller，从而进入caller.run(),也就是MethodAndArgsCaller.run()方法。</p>
<h3 id="ZygoteInit-runSelectLoop()">ZygoteInit.runSelectLoop()</h3><p>这个方法是zygote用来监听和处理创建应用进程的请求.注意此方法是一个死循环!!!通过ZygoteConnection.runOnce()抛出MethodAndArgsCaller异常返回ZygoteInit.main中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 zygote socket 的 fd加入数组</span></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用到了linux的poll机制</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">          <span class="comment">//采用I/O多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过continue，执行后面的代码</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//表示zygote socket中有连接到来,那么就要创建客户端连接</span></span><br><span class="line">                <span class="comment">// 实际上就是执行socket accept操作</span></span><br><span class="line">                <span class="comment">// 然后把创建的这个连接也加入到监听数组中,索引肯定大于0了</span></span><br><span class="line">                <span class="comment">// 那么一旦这个连接中有数据来了,i肯定大于0</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用ZygoteConnection.runOnce()处理客户端数据事务</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                <span class="comment">// 处理完之后,断开连接,并且不在监听这个连接</span></span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ZygoteConnection-runOnce()">ZygoteConnection.runOnce()</h3><p>这个方法首先肯定是先从 socket接受传递过来的启动进程的线骨干参数.然后解析参数.检查权限,创建进程,然后处理父子进程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">  String args[];</span><br><span class="line">  Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">  FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//接受参数</span></span><br><span class="line">      args = readArgumentList();</span><br><span class="line">      descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">     ........................</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 解析参数</span></span><br><span class="line">     parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">     .......</span><br><span class="line">     <span class="comment">// 权限检查</span></span><br><span class="line">     applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">     applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line">     applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">     applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">     .....</span><br><span class="line">     pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                  parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                  parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                  parsedArgs.appDataDir);</span><br><span class="line">   &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">     ......</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// in child</span></span><br><span class="line">           <span class="comment">// 创建的app进程</span></span><br><span class="line">           IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">           serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">           handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">           <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">           <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">           <span class="comment">// zygote进程</span></span><br><span class="line">           IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">           childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">       IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Zygote-forkAndSpecialize()方法">Zygote.forkAndSpecialize()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span><br><span class="line">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span><br><span class="line">      String instructionSet, String appDataDir)</span> </span>&#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir);</span><br><span class="line">    <span class="comment">// Enable tracing as soon as possible for the child process.</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that this event ends at the end of handleChildProc,</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"PostFork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知zygote孵化进程还是依靠的jni native方法完成的.</p>
<p>在真正孵化进程之前,要做一些前期工作,比如暂停zygote中运行的线程,从而提高fork效率.这些是由VM_HOOKS.preFork()完成的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preFork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Daemons.stop();<span class="comment">//停止4个Daemon子线程</span></span><br><span class="line">    waitUntilAllThreadsStopped();<span class="comment">//等待所有子线程结束</span></span><br><span class="line">    token = nativePreFork();<span class="comment">//完成gc堆的初始化工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop(); <span class="comment">//Java堆整理线程</span></span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop(); <span class="comment">//引用队列线程</span></span><br><span class="line">    FinalizerDaemon.INSTANCE.stop(); <span class="comment">//析构线程</span></span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); <span class="comment">//析构监控线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>守护线程Stop方式是先调用目标线程interrrupt()方法，然后再调用目标线程join()方法，等待线程执行完成.</p>
<h3 id="Zygote-nativeForkAndSpecialize()方法">Zygote.nativeForkAndSpecialize()方法</h3><p>源码路径:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android-6/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span><br><span class="line">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits,</span><br><span class="line">        jint mount_external, jstring se_info, jstring se_name,</span><br><span class="line">        jintArray fdsToClose, jstring instructionSet, jstring appDataDir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Grant CAP_WAKE_ALARM to the Bluetooth process.</span></span><br><span class="line">    jlong capabilities = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (uid == AID_BLUETOOTH) &#123;</span><br><span class="line">        capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, <span class="literal">false</span>, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用下面的方法创建进程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     <span class="keyword">bool</span> is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程的signal信号处理函数</span></span><br><span class="line">  SetSigChldHandler();</span><br><span class="line">  <span class="comment">// fork进程</span></span><br><span class="line">  <span class="comment">// 父进程中，fork返回新创建的子进程的pid;</span></span><br><span class="line">  <span class="comment">// 子进程中，fork返回0</span></span><br><span class="line">  <span class="comment">// 执行完这句代码,后面的代码父子进程都会执行,所以要根据返回值做不同处理.</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// app进程</span></span><br><span class="line">    gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line">    DetachDescriptors(env, fdsToClose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep capabilities across UID change, unless we're staying root.</span></span><br><span class="line">    <span class="comment">// 使用linux capabilities 权限机制,root进程不使用</span></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">      EnableKeepCapabilities(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于前面开始了capabilities机制,所以可以放弃某些app进程不该拥有的能力了</span></span><br><span class="line">    DropCapabilitiesBoundingSet(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x86架构运行arm文件时,需要一个bridge</span></span><br><span class="line">    <span class="keyword">bool</span> use_native_bridge = !is_system_server &amp;&amp; (instructionSet != <span class="literal">NULL</span>)</span><br><span class="line">        &amp;&amp; android::NativeBridgeAvailable();</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge &amp;&amp; dataDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      use_native_bridge = <span class="literal">false</span>;</span><br><span class="line">      ALOGW(<span class="string">"Native bridge will not be used because dataDir == NULL."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进程外置外部存储</span></span><br><span class="line">    <span class="comment">// 6.0中,因为允许动态授权权限,比如说app申请了对外部存储的读写权限,可能用户之后会关闭写权限等</span></span><br><span class="line">    <span class="comment">// 所以6.0中,改变了对外部存储的管理策略,这个以后单独讲</span></span><br><span class="line">    <span class="comment">// 这里只需要直到根据mount_external</span></span><br><span class="line">    <span class="comment">// 有三个挂在点:/mnt/runtime/default,storageSource = "/mnt/runtime/read",storageSource = "/mnt/runtime/write"</span></span><br><span class="line">    <span class="comment">// 6.0之前,都是直接指向外部存储的</span></span><br><span class="line">    <span class="keyword">if</span> (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</span><br><span class="line">      ALOGW(<span class="string">"Failed to mount emulated storage: %s"</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOTCONN || errno == EROFS) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"Cannot continue without emulated storage"</span>);</span><br><span class="line">        RuntimeAbort(env);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">       <span class="comment">//对于非system_server子进程，则创建进程组</span></span><br><span class="line">       <span class="comment">// 创建文件夹/acct/uid_&lt;uid&gt;/,权限0750,system:system</span></span><br><span class="line">       <span class="comment">// 创建文件夹/acct/uid_&lt;uid&gt;/pid_&lt;pid&gt;,权限0750,system:system</span></span><br><span class="line">       <span class="comment">// open文件/acct/uid_&lt;uid&gt;/pid_&lt;pid&gt;/cgroup.procs,记录进程号</span></span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">          .......................</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置设置group</span></span><br><span class="line">    SetGids(env, javaGids);</span><br><span class="line">    <span class="comment">//设置资源limit</span></span><br><span class="line">    SetRLimits(env, javaRlimits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">data_dir</span><span class="params">(env, dataDir)</span></span>;</span><br><span class="line">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresgid(%d) failed: %s"</span>, gid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresuid(%d) failed: %s"</span>, uid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NeedsNoRandomizeWorkaround()) &#123;</span><br><span class="line">        <span class="comment">// Work around ARM kernel ASLR lossage (http://b/5817320).</span></span><br><span class="line">        <span class="keyword">int</span> old_personality = personality(<span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="keyword">int</span> new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</span><br><span class="line">        <span class="keyword">if</span> (new_personality == -<span class="number">1</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"personality(%d) failed: %s"</span>, new_personality, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置能力,除了蓝颜进程外,其他app进程,permittedCapabilities为0</span></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="comment">//设置调度策略</span></span><br><span class="line">    SetSchedulerPolicy(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_info_c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// PMS在app安装的时候,就会记录seinfo.第三方app一般都为default.</span></span><br><span class="line">    ScopedUtfChars* se_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (java_se_info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        se_info = <span class="keyword">new</span> ScopedUtfChars(env, java_se_info);</span><br><span class="line">        se_info_c_str = se_info-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_info_c_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          ALOGE(<span class="string">"se_info_c_str == NULL"</span>);</span><br><span class="line">          RuntimeAbort(env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_name_c_str = <span class="literal">NULL</span>;</span><br><span class="line">    ScopedUtfChars* se_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (java_se_name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        se_name = <span class="keyword">new</span> ScopedUtfChars(env, java_se_name);</span><br><span class="line">        se_name_c_str = se_name-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          ALOGE(<span class="string">"se_name_c_str == NULL"</span>);</span><br><span class="line">          RuntimeAbort(env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置selinux上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"selinux_android_setcontext(%d, %d, \"%s\", \"%s\") failed"</span>, uid,</span><br><span class="line">            is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">      RuntimeAbort(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make it easier to debug audit logs by setting the main thread's name to the</span></span><br><span class="line">    <span class="comment">// nice name rather than "app_process".</span></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == <span class="literal">NULL</span> &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三方app为default</span></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> se_info;</span><br><span class="line">    <span class="keyword">delete</span> se_name;</span><br><span class="line">   <span class="comment">//在Zygote子进程中，设置信号SIGCHLD的处理器恢复为默认行为</span></span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line">    <span class="comment">//调用zygote.callPostForkChildHooks()</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? <span class="literal">NULL</span> : instructionSet);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      ALOGE(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">      RuntimeAbort(env);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// the parent process</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callPostForkChildHooks</span><span class="params">(<span class="keyword">int</span> debugFlags, String instructionSet)</span> </span>&#123;</span><br><span class="line">      VM_HOOKS.postForkChild(debugFlags, instructionSet);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkChild</span><span class="params">(<span class="keyword">int</span> debugFlags, String instructionSet)</span> </span>&#123;</span><br><span class="line">    nativePostForkChild(token, debugFlags, instructionSet);</span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteHooks_nativePostForkChild</span><span class="params">(JNIEnv* env, jclass, jlong token, jint debug_flags,</span><br><span class="line">                                            jstring instruction_set)</span> </span>&#123;</span><br><span class="line">    Thread* thread = <span class="keyword">reinterpret_cast</span>&lt;Thread*&gt;(token);</span><br><span class="line">    <span class="comment">//设置新进程的主线程id</span></span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">if</span> (instruction_set != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instruction_set)</span></span>;</span><br><span class="line">      InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">      Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">      <span class="keyword">if</span> (isa != kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">        action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//【见流程6-2-2-1-1-1】</span></span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, action, isa_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Runtime::Current()-&gt;DidForkFromZygote(env, Runtime::NativeBridgeAction::kUnload, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Runtime::DidForkFromZygote(JNIEnv* env, NativeBridgeAction action, <span class="keyword">const</span> <span class="keyword">char</span>* isa) &#123;</span><br><span class="line">  is_zygote_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (is_native_bridge_loaded_) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge(); <span class="comment">//卸载用于跨平台的桥连库</span></span><br><span class="line">        is_native_bridge_loaded_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);<span class="comment">//初始化用于跨平台的桥连库</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建Java堆处理的线程池</span></span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  <span class="comment">//重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span></span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line">  <span class="keyword">if</span> (jit_.get() == <span class="literal">nullptr</span> &amp;&amp; jit_options_-&gt;UseJIT()) &#123;</span><br><span class="line">    <span class="comment">//当flag被设置，并且还没有创建JIT时，则创建JIT</span></span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置信号处理函数</span></span><br><span class="line">  StartSignalCatcher();</span><br><span class="line">  <span class="comment">//启动JDWP线程，当命令debuger的flags指定"suspend=y"时，则暂停runtime</span></span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继续看Zygote-forkAndSpecialize()">继续看Zygote.forkAndSpecialize()</h3><p>会调用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM_HOOKS.postForkCommon();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VM_HOOKS.postForkCommon的主要功能是在fork新进程后，启动Zygote的4个Daemon线程，java堆整理，引用队列，以及析构线程(前面暂停了)。</p>
<p><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-19.png" alt=""></p>
<h3 id="ZygoteConnection-handleChildProc()–子进程初始化">ZygoteConnection.handleChildProc()–子进程初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span><br><span class="line">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span><br><span class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭Zygote的socket两端的连接</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line">    <span class="comment">// 关闭从zygote继承的文件描述</span></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error reopening stdio"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置进程名</span></span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ...........................</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//执行ActivityThread.main</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RuntimeInit-ZygoteInit()方法">RuntimeInit.ZygoteInit()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span><br><span class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    <span class="comment">//重定向log输出</span></span><br><span class="line">    redirectLogStreams();</span><br><span class="line">    <span class="comment">//一些初始化</span></span><br><span class="line">    commonInit();</span><br><span class="line">    <span class="comment">// zygote初始化</span></span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 应用初始化</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RuntimeInit-commonInit()方法">RuntimeInit.commonInit()方法</h3><p>commonInit()方法主要进行一些简单初始化:设置异常处理,设置时区,重置Android log 系统,设置http.agent属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置默认的未捕捉异常处理方法</span></span><br><span class="line">    <span class="comment">// app也可以调用这个方法设置自己的处理方法,例如在处理方法中把产生的异常信息发送到公司服务器中</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置市区，中国时区为"Asia/Shanghai"</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket的tag，用于网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RuntimeInit-nativeZygoteInit()方法">RuntimeInit.nativeZygoteInit()方法</h3><p>源码路径:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android-6/frameworks/base/core/jni/AndroidRuntime.cpp&#10;Android-6/frameworks/base/cmds/app_process/App_main.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit(); <span class="comment">//此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">//启动新binder线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver().</p>
<p>该方法主要进行binder的初始化,这样app就可以使用binder了.</p>
<h3 id="RuntimeInit-applicationInit()方法">RuntimeInit.applicationInit()方法</h3><p>开始指向ActivityThread.main().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span><br><span class="line">          <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">      <span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">      nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//设置虚拟机的内存利用率参数值为0.75</span></span><br><span class="line">      VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">      VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Arguments args;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">          Slog.e(TAG, ex.getMessage());</span><br><span class="line">          <span class="comment">// let the process exit</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">      invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="RuntimeInit-invokeStaticMain()方法">RuntimeInit.invokeStaticMain()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span><br><span class="line">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 传入的classLoader为null</span></span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到main方法</span></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main方法必须是static public类型的</span></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。</span></span><br><span class="line">    <span class="comment">// m就是找到的main方法</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MethodAndArgsCaller-run()方法">MethodAndArgsCaller.run()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// mMethod就是ActivityThread.main方法</span></span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-20.png" alt=""></p>
<p>到此位置app的进程算是创建完毕了,进程执行的第一个方法也找到是谁了.</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/07/Android_ActivityManagerService-5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Android6.0之AMS如何启动app上篇
        
      </div>
    </a>
  
  
    <a href="/2016/07/07/Android_ActivityManagerService-6/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android6.0之Activity的管理与启动模式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Android_ActivityManagerService-8" data-title="Android6.0之AMS启动app中篇之创建app进程" data-url="http://www.iloveandroid.net/2016/07/07/Android_ActivityManagerService-8/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"iloveandroid"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 genglei.cuan
   <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256335558'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256335558%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> 
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>