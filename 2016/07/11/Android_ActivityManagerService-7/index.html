<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android6.0之AMS如何启动app中篇之Task的管理 | 码农故事</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前面分析到了ActivityStackSupervisor类中的startActivityLocked方法,现在接着分析.">
<meta property="og:type" content="article">
<meta property="og:title" content="Android6.0之AMS如何启动app中篇之Task的管理">
<meta property="og:url" content="http://www.iloveandroid.net/2016/07/11/Android_ActivityManagerService-7/index.html">
<meta property="og:site_name" content="码农故事">
<meta property="og:description" content="前面分析到了ActivityStackSupervisor类中的startActivityLocked方法,现在接着分析.">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-12.gif">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-13.gif">
<meta property="og:image" content="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-10.png">
<meta property="og:updated_time" content="2016-07-21T09:21:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android6.0之AMS如何启动app中篇之Task的管理">
<meta name="twitter:description" content="前面分析到了ActivityStackSupervisor类中的startActivityLocked方法,现在接着分析.">
  
    <link rel="alternative" href="/atom.xml" title="码农故事" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">genglei.cuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不断成长的见证</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/linux基础">linux基础</a></li>
				        
							<li><a href="/categories/Android底层开发">Android底层开发</a></li>
				        
							<li><a href="/categories/App开发">App开发</a></li>
				        
							<li><a href="/categories/项目管理">项目管理</a></li>
				        
							<li><a href="/categories/Python">Python</a></li>
				        
							<li><a href="/categories/开源框架">开源框架</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android刷机/" style="font-size: 10px;">Android刷机</a> <a href="/tags/Android底层/" style="font-size: 10px;">Android底层</a> <a href="/tags/Android核心服务/" style="font-size: 20px;">Android核心服务</a> <a href="/tags/Android编译/" style="font-size: 11.43px;">Android编译</a> <a href="/tags/Gradle/" style="font-size: 15.71px;">Gradle</a> <a href="/tags/linux常用命令/" style="font-size: 10px;">linux常用命令</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/代码管理/" style="font-size: 18.57px;">代码管理</a> <a href="/tags/应用开发/" style="font-size: 10px;">应用开发</a> <a href="/tags/提高效率/" style="font-size: 10px;">提高效率</a> <a href="/tags/构建/" style="font-size: 15.71px;">构建</a> <a href="/tags/签名认证/" style="font-size: 11.43px;">签名认证</a> <a href="/tags/自动化测试/" style="font-size: 14.29px;">自动化测试</a> <a href="/tags/调试/" style="font-size: 12.86px;">调试</a> <a href="/tags/逆向工程/" style="font-size: 17.14px;">逆向工程</a> <a href="/tags/逆向开发/" style="font-size: 18.57px;">逆向开发</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">码农的成长之路，不要让昨日的悲伤，浪费今天的眼泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">genglei.cuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">genglei.cuan</h1>
			</hgroup>
			
			<p class="header-subtitle">不断成长的见证</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/linux基础">linux基础</a></li>
		        
					<li><a href="/categories/Android底层开发">Android底层开发</a></li>
		        
					<li><a href="/categories/App开发">App开发</a></li>
		        
					<li><a href="/categories/项目管理">项目管理</a></li>
		        
					<li><a href="/categories/Python">Python</a></li>
		        
					<li><a href="/categories/开源框架">开源框架</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Android_ActivityManagerService-7" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/Android_ActivityManagerService-7/" class="article-date">
  	<time datetime="2016-07-11T11:21:53.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android6.0之AMS如何启动app中篇之Task的管理
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android核心服务/">Android核心服务</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android底层开发/">Android底层开发</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面分析到了ActivityStackSupervisor类中的startActivityLocked方法,现在接着分析.</p>
<a id="more"></a>
<h3 id="startActivityLocked">startActivityLocked</h3><p>利用传入的IApplicationThread caller,从AMS中得到调用者进程信息,也就是Launcher进程的信息.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(</span><br><span class="line">           IApplicationThread caller,//AMS通过这个参数可以和发起者进行交互</span><br><span class="line">           Intent intent,// 启动activity的intent</span><br><span class="line">           String resolvedType, // intent的类型,也就是MIME type</span><br><span class="line">           ActivityInfo aInfo,//要启动的activity的信息</span><br><span class="line">           IVoiceInteractionSession voiceSession,</span><br><span class="line">           IVoiceInteractor voiceInteractor,</span><br><span class="line">           IBinder resultTo,//用于接收startActivityForResult的结果,launcher启动app这种情景下没有用,为<span class="keyword">null</span></span><br><span class="line">           String resultWho,</span><br><span class="line">           <span class="keyword">int</span> requestCode,// 传入的-<span class="number">1</span></span><br><span class="line">           <span class="keyword">int</span> callingPid,</span><br><span class="line">           <span class="keyword">int</span> callingUid,</span><br><span class="line">           String callingPackage,</span><br><span class="line">           <span class="keyword">int</span> realCallingPid,</span><br><span class="line">           <span class="keyword">int</span> realCallingUid,</span><br><span class="line">           <span class="keyword">int</span> startFlags,// 传入的为<span class="number">0</span></span><br><span class="line">           Bundle options,</span><br><span class="line">           <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">           ActivityContainer container, // 启动app时,传入的为<span class="keyword">null</span></span><br><span class="line">           TaskRecord inTask)</span> <span class="comment">// 启动app时,传入为null</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line"></span><br><span class="line">       ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">           callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">          ................</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里顺便简单的对startActivityLocked方法的几个关键的参数根据代码做一个解释。<br>IApplicationThread caller :请求启动当前Activity的应用方，IApplicationThread 类型是AMS IPC调用ActivityThread的IBinder接口,如下图所示:<br><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-12.gif" alt=""></p>
<p> IBinder resultTo: 调用方Activity的ActivityRecord，每个Activity在启动之后，AMS均会将这个Activity的ActivityRecord的IBinder再传递给Activity，作为其在AMS中的标识。因此此时的resultTo经过2次IPC传递之后，已经不再是接口了，回到AMS之后就会再次变为ActivityRecord。这个参数后面会详解.</p>
<p> callingPid和callingUid: 如果caller为空，其为请求启动Activity的进程的PID和UID；caller不为空，为caller activity所在的进程的PID和UID，基本上是一码事。这个PID和UID为了权限检查用的，检查当前的请求方是否有权限启动这个Activity。</p>
<h4 id="接着从intent中拿到启动activity的flag-">接着从intent中拿到启动activity的flag.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 启动app时,传入为null</span></span><br><span class="line"><span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sourceRecord = isInAnyStackLocked(resultTo);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">            <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">            resultRecord = sourceRecord;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从intent中拿到启动activity的flag</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line"><span class="comment">//因为sourceRecord为null,所以不走这段代码</span></span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还要确定sourceRecord和resultRecord,这两个变量均为ActivityRecord类型，前者代表请求启动当前activity的activity；后者表示当前的activity在启动之后需要返回结果的ActivityRecord，一般情况下，如果sourceRecord的activity使用startActivityForResult()启动当前activity并且requestCode&gt;=0时，则resultRecord不为空，且resultRecord=sourceRecord。</p>
<p>只不过当从launcher启动app时,requestCode为-1.</p>
<p>还有一种特殊的情况，当启动一个activity时，启动的Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，在这种情况resultRecord并不指向sourceRecord，而是指向sourceRecord的sourceRecord.</p>
<p>如下图所示:<br><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-13.gif" alt=""></p>
<p>Activity A 启动了Activity B，Activity B又启动了C，A–&gt;B–&gt;C, 这种情况下，A启动B要求B返回result给A，但是如果B在启动C时，Intent设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT标志，那么此时将会交由C向A setResult。为了避免冲突，B启动C时不得指定resultRecord&gt;=0。</p>
<h4 id="接着是检查权限:">接着是检查权限:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> startAnyPerm = mService.checkPermission(</span><br><span class="line">    START_ANY_ACTIVITY, callingPid, callingUid);</span><br></pre></td></tr></table></figure>
<p>检查权限的规则:</p>
<ol>
<li><p>Root uid(0), System Server uid (Process.SYSTEM_UID), own process(MY_PID),将授权permission</p>
</li>
<li><p>如果发起者是被隔离的app,那么拒绝授权permission</p>
</li>
<li><p>如果请求启动的activity的属性android:exported=false， 并且请求的callingUid不等于请求启动的activity的UID，不允许启动；</p>
</li>
<li><p>请求启动的activity没有设定permission，只有当activity的permission和其所在的application的android:permission均没有设置时才为null，设置了application未设置activity，那么activity的permission与application相同。activity的permission为空，将授权permission</p>
</li>
<li><p>请求启动的activity设定了permission，那么检查请求方的activity中是否声明了使用这个permission，如果声明，授权。</p>
</li>
</ol>
<p>intent防火墙规则检查,看是否防火墙屏蔽了启动这个app的intent:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">                callingPid, resolvedType, aInfo.applicationInfo);</span><br></pre></td></tr></table></figure>
<p>防火墙规则目录在</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/system/ifw</span><br></pre></td></tr></table></figure>
<p>这个文件夹中,可以设置系统禁止某些intent.</p>
<p>接着将Activity启动的消息通知监听Activity变动的的接口IActivityController,AMS有任何动静都将回调该监听者.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// The Intent we give to the watcher has the extra data</span></span><br><span class="line">              <span class="comment">// stripped off, since it can contain private information.</span></span><br><span class="line">              Intent watchIntent = intent.cloneFilter();</span><br><span class="line">              abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                      aInfo.applicationInfo.packageName);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">              mService.mController = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下是不会设置这个监听者的,只有当debug时才会设置.例如在进行Monkey测试的时候，Monkey会设置该回调对象。这样，Monkey就能根据AMS反馈的情况进行相应处理了.</p>
<h4 id="接着是为启动的App的主activity创建ActivityRecord对象:">接着是为启动的App的主activity创建ActivityRecord对象:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">             intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">             requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, <span class="keyword">this</span>, container, options);</span><br></pre></td></tr></table></figure>
<h4 id="接着是获取恰当的ActivityStack:">接着是获取恰当的ActivityStack:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityStack stack = mFocusedStack;</span><br></pre></td></tr></table></figure>
<p>其中mFocusedStack前面已经介绍了,也是ActivityStackSupervisor类中的定义的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The stack currently receiving input or launching the next activity. */</span></span><br><span class="line"><span class="keyword">private</span> ActivityStack mFocusedStack;</span><br></pre></td></tr></table></figure></p>
<h4 id="接着检查启动activity是否会引起进程切换，如果需要的话，还要检查Android系统目前是否允许切换。">接着检查启动activity是否会引起进程切换，如果需要的话，还要检查Android系统目前是否允许切换。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityStack stack = mFocusedStack;</span><br><span class="line">     <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; (stack.mResumedActivity == <span class="keyword">null</span></span><br><span class="line">             || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                 realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">             PendingActivityLaunch pal =</span><br><span class="line">                     <span class="keyword">new</span> PendingActivityLaunch(r, sourceRecord, startFlags, stack);</span><br><span class="line">             mPendingActivityLaunches.add(pal);</span><br><span class="line">             ActivityOptions.abort(options);</span><br><span class="line">             <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>什么情况不允许切换呢？最常见的例子就是打电话的时候，如果是位于通话界面的话，可以通过AMS的stopAppSwitches来禁止切换掉当前进程，这个方法会使其他Task的Activity无法显示在前端，但同一个Task中的Activity则不受制约.电话结束后再调用resumeAppSwitches来恢复切换。为了防止使用者不调用resumeAppSwitches，系统设置了一个超时时间（5s），超时则自动resume。需要注意的是，这个接口一般的普通的app是不能调用的，因此这个操作一定是系统app操作的。</p>
<p>如果没有则储存起来，有机会再启动它。将保存到mPendingActivityLaunchers中.</p>
<p>如果允许进程切换的话:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doPendingActivityLaunchesLocked(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>启动处于Pending状态的Activity，即之前由于上一步被禁止切换而保存起来的请求。它将先于本次需要启动的Activity处理.</p>
<p>然后再调用startActivityUncheckedLocked方法继续处理当前方法继续处理当前的activity。(其实处理Pending状态的Activity,也是调用startActivityUncheckedLocked方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">              startFlags, <span class="keyword">true</span>, options, inTask);</span><br></pre></td></tr></table></figure>
<p>整个startActivityLocked方法主要调用时序图如下所示:</p>
<p><img src="http://7xj6ce.com1.z0.glb.clouddn.com/AMS-10.png" alt=""></p>
<h3 id="startActivityUncheckedLocked">startActivityUncheckedLocked</h3><p>接下来分析startActivityUncheckedLocked,这个方法代码很长,分为若干阶段. 该方法主要负责task的管理,也可以理解为task的调度.在换句话说,也可以理解为找到或者创建一个合适的task.</p>
<p>先分析参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityUncheckedLocked</span><span class="params">(</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r,// 创建的activity</span><br><span class="line">         ActivityRecord sourceRecord, // 启动方</span><br><span class="line">        IVoiceInteractionSession voiceSession,</span><br><span class="line">        IVoiceInteractor voiceInteractor,</span><br><span class="line">         <span class="keyword">int</span> startFlags,//</span><br><span class="line">        <span class="keyword">boolean</span> doResume,// 传入的<span class="keyword">true</span></span><br><span class="line">         Bundle options,</span><br><span class="line">          TaskRecord inTask // 在最近任务列表中的task,没有的话 为<span class="keyword">null</span></span><br><span class="line">          )</span></span></span><br></pre></td></tr></table></figure>
<p>获取Activity的启动模式,这些都是PMS从AndroidManifest.xml文件中获取的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK;</span><br></pre></td></tr></table></figure>
<p>接着获取启动Activity的flag:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> launchFlags = intent.getFlags();</span><br></pre></td></tr></table></figure>
<p>然后就开始依据flag进行相应的处理,例如是否需要创建新的task等等.</p>
<p>首先处理AndroidManifest.xml和intent flag冲突的问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//launchSingleInstance与launchSingleTask都是从AndroidManifest.xml文件中获取的</span></span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (launchSingleInstance || launchSingleTask)) &#123;</span><br><span class="line">            <span class="comment">// We have a conflict between the Intent and the Activity manifest, manifest wins.</span></span><br><span class="line">            Slog.i(TAG, <span class="string">"Ignoring FLAG_ACTIVITY_NEW_DOCUMENT, launchMode is "</span> +</span><br><span class="line">                    <span class="string">"\"singleInstance\" or \"singleTask\""</span>);</span><br><span class="line">            <span class="comment">// 当flag中包含FLAG_ACTIVITY_NEW_DOCUMENT,而activity启动模式为SingleInstance或者SingleTask时,</span></span><br><span class="line">            <span class="comment">// 这个标志包括FLAG_ACTIVITY_MULTIPLE_TASK会被忽略.</span></span><br><span class="line">            launchFlags &amp;=</span><br><span class="line">                    ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果AndroidManifest.xml设置了documentLaunchMode</span></span><br><span class="line">           <span class="comment">// 那么依据此来修改flag.</span></span><br><span class="line">            <span class="keyword">switch</span> (r.info.documentLaunchMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ActivityInfo.DOCUMENT_LAUNCH_NONE:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityInfo.DOCUMENT_LAUNCH_INTO_EXISTING:</span><br><span class="line">                    launchFlags |= Intent.FLAG_ACTIVITY_NEW_DOCUMENT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityInfo.DOCUMENT_LAUNCH_ALWAYS:</span><br><span class="line">                    launchFlags |= Intent.FLAG_ACTIVITY_NEW_DOCUMENT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityInfo.DOCUMENT_LAUNCH_NEVER:</span><br><span class="line">                    launchFlags &amp;= ~Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可知,AndroidManifest.xml设置的documentLaunchMode标签属性优先级高于flag.</p>
<p>接下来处理当flag中设置Intent.FLAG_ACTIVITY_NEW_TASK时断开与Caller依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span> &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span></span><br><span class="line">               &amp;&amp; r.resultTo.task.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Slog.w(TAG, <span class="string">"Activity is launching as a new task, so cancelling activity result."</span>);</span><br><span class="line">           r.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>,</span><br><span class="line">                   r.resultTo, r.resultWho, r.requestCode,</span><br><span class="line">                   Activity.RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">           r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>如果启动的activity需要新的task，那么新启动的activity将会与其caller断开依赖关系，这个关系主要是指result反馈，A–&gt;B,如果A是通过startActivityForResult()请求启动的，并且requestCode &gt;=0,那么如果B是在新的task中，那么B在finish的时候将不再向A反馈result，而是在启动过程中就会向A反馈一个RESULT_CANCELED。</p>
<p>因为FLAG_ACTIVITY_NEW_DOCUMENT,会在overview screen以一个task的形式展示,所以这里要为包含FLAG_ACTIVITY_NEW_DOCUMENT的的flag增添一个FLAG_ACTIVITY_NEW_TASK标志:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != <span class="number">0</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为FLAG_ACTIVITY_NEW_TASK标志,会首先检查是他要启动的activity的taskAffinity属性指定的task是否存在(taskAffinity没指定的话,默认就是其app包名),不存在的话,才会尝试去新建一个task.</p>
<p>所以FLAG_ACTIVITY_NEW_TASK标志并不能保证一定要新建一个task.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> launchTaskBehind = r.mLaunchTaskBehind</span><br><span class="line">               &amp;&amp; !launchSingleTask &amp;&amp; !launchSingleInstance</span><br><span class="line">               &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (launchTaskBehind</span><br><span class="line">                    || r.info.documentLaunchMode == ActivityInfo.DOCUMENT_LAUNCH_ALWAYS) &#123;</span><br><span class="line">                launchFlags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当activity设置documentLaunchMode为DOCUMENT_LAUNCH_ALWAYS时,就要在添加FLAG_ACTIVITY_MULTIPLE_TASK这个标志,结合FLAG_ACTIVITY_NEW_TASK,就能保证每次都新建一个task了.</p>
<p>接着处理FLAG_ACTIVITY_NO_USER_ACTION:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mUserLeaving = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_USER_ACTION) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,</span><br><span class="line">        <span class="string">"startActivity() =&gt; mUserLeaving="</span> + mUserLeaving);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当从launcher启动app时,传入的为true,所以部不执行</span></span><br><span class="line"><span class="keyword">if</span> (!doResume) &#123;</span><br><span class="line">    r.delayedResume = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一般情况下，启动一个Activity时都不使用该标识，如果不包含该标识，AMS会判断一定的时间内是否有用户交互。如果没有用户交互的话，AMS会通知Activity回调onUserLeaving()方法，然后再回调onPause()方法，如果使用了该标识，说明目标Activity不和用户交互，所以也就不需要回调onUserLeaving()方法。</p>
<p>确定是否现在就Resume,如果不需要立即Resume，就把r.delayResume为true，意思是延迟Resume。</p>
<p>接着处理FLAG_ACTIVITY_PREVIOUS_IS_TOP,这个标志很奇葩.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord notTop =</span><br><span class="line">              (launchFlags &amp; Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != <span class="number">0</span> ? r : <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">           ActivityRecord checkedCaller = sourceRecord;</span><br><span class="line">           <span class="keyword">if</span> (checkedCaller == <span class="keyword">null</span>) &#123;</span><br><span class="line">               checkedCaller = mFocusedStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!checkedCaller.realActivity.equals(r.realActivity)) &#123;</span><br><span class="line">               <span class="comment">// Caller is not the same as launcher, so always needed.</span></span><br><span class="line">               startFlags &amp;= ~ActivityManager.START_FLAG_ONLY_IF_NEEDED;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>它的注释可以看出它的含义是指如果设置了该flag，那么mHistory中最top的activity在后续的处理中将不被视为top，而将前一个activity视为top，如A–&gt;B–&gt;C，将B视为top。</p>
<p>这个top activity的作用很大，涉及到后面对task的处理。但是目前来看这个flag并没有起到该有的作用，代码中判断如果设置了该标志，那么AMS将会视当前正在启动的activity为top，然后去mHistory中去查找它的前一个activity为后续task处理的top activity(topRunningNonDelayedActivityLocked()中实现)，但是现在的问题是此时此刻，正在启动的activity并不存在于mHistory中，因为我们在前一个函数中刚刚创建了这个ActivityRecord。</p>
<p>所以这个flag基本没用,而且当从launcher启动app时,也没有设置该flag.</p>
<p>接下来处理inTask不为null的情况,当从launcher启动app时,该参数为null,所以略过这段代码.其实该段代码与从最近列表启动activity有关系.后面会单独讲解.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sourceRecord == <span class="keyword">null</span> &amp;&amp; inTask != <span class="keyword">null</span> &amp;&amp; inTask.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">      .........</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inTask = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的这段代码,是给flag添加FLAG_ACTIVITY_NEW_TASK</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sourceRecord == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This activity is not being started from another...  in this</span></span><br><span class="line">      <span class="comment">// case we -always- start a new task.</span></span><br><span class="line">      <span class="comment">// 当初launcher启动app时,走这里</span></span><br><span class="line">      <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span> &amp;&amp; inTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">          Slog.w(TAG, <span class="string">"startActivity called from non-Activity context; forcing "</span> +</span><br><span class="line">                  <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + intent);</span><br><span class="line">          launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">      <span class="comment">// The original activity who is starting us is running as a single</span></span><br><span class="line">      <span class="comment">// instance...  this new activity it is starting must go on its</span></span><br><span class="line">      <span class="comment">// own task.</span></span><br><span class="line">      launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (launchSingleInstance || launchSingleTask) &#123;</span><br><span class="line">      <span class="comment">// The activity being started is a single instance...  it always</span></span><br><span class="line">      <span class="comment">// gets launched into its own task.</span></span><br><span class="line">      launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码可以知道,当sourceRecord为null,且该activity不在最近列表中,那么就要给flag添加FLAG_ACTIVITY_NEW_TASK(如果没有的话).</p>
<p>当sourceRecord不为null,也就是说是从另一个activity中启动该activity的,那么如果sourceRecord所代表的activity的启动模式,是singleinstance的话,也要给flag添加FLAG_ACTIVITY_NEW_TASK.</p>
<p>最后就是当要启动的activity自己设置了启动模式为SingleInstance或者SingleTask,也要给flag添加FLAG_ACTIVITY_NEW_TASK.</p>
<p>接下来的这段代码是一个保险的检查,可能启动这个activity的activity要被销毁了(从launcher启动app,不走这段代码,因为sourceRecord为null)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo newTaskInfo = <span class="keyword">null</span>;</span><br><span class="line">Intent newTaskIntent = <span class="keyword">null</span>;</span><br><span class="line">ActivityStack sourceStack;</span><br><span class="line"><span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sourceRecord.finishing) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">          Slog.w(TAG, <span class="string">"startActivity called from finishing "</span> + sourceRecord</span><br><span class="line">                  + <span class="string">"; forcing "</span> + <span class="string">"Intent.FLAG_ACTIVITY_NEW_TASK for: "</span> + intent);</span><br><span class="line">          launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">          <span class="comment">// 启动activity的发起者的向关系</span></span><br><span class="line">          newTaskInfo = sourceRecord.info;</span><br><span class="line">          <span class="comment">// 创建原task时的intent,也就是启动这个task 根activity的intent</span></span><br><span class="line">          newTaskIntent = sourceRecord.task.intent;</span><br><span class="line">      &#125;</span><br><span class="line">      sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">      sourceStack = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sourceStack = sourceRecord.task.stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sourceStack = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是检查启动它的activity是不是快要被销毁了，那么可能task也要销毁,如果是的话那就后面需要启动一个新的task，从而将这个activity放到这个task中去。,所以这里提前保存一些相关信息.</p>
<p>接下来的一段代码就开始着手寻找一个合适的task来存放这个即将启动的activity,如果没有的话,就创建一个新task.</p>
<p>AMS首先肯定是努力寻找一个已经存在的task:</p>
<p>FLAG_ACTIVITY_NEW_TASK标志表示想要重新创建一个task,但是未必一定要新建.</p>
<p>当有FLAG_ACTIVITY_NEW_TASK,但没有设置FLAG_ACTIVITY_MULTIPLE_TASK,或者当前启动的activity是SingleInstance or SingleTask模式,通过前面文章的介绍可知,AMS会尝试需找豁然activity中taskAffinity同名的task是否存在,不存在才创建.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if语句中的三个条件下需要查找是否有可复用的task</span></span><br><span class="line"><span class="keyword">if</span> (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == <span class="number">0</span>)</span><br><span class="line">             || launchSingleInstance || launchSingleTask)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span> (inTask == <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是非SingleInstance启动模式,则利用findTaskLocked查找</span></span><br><span class="line">                <span class="comment">// 如果是 SingleInstance启动模式,则利用findActivityLocked查找.</span></span><br><span class="line">                <span class="comment">// 这两个方法返回的是找到的task的顶端的activity,并不一定是要启动的activity</span></span><br><span class="line">                ActivityRecord intentActivity = !launchSingleInstance ?</span><br><span class="line">                        findTaskLocked(r) : findActivityLocked(intent, r.info);</span><br><span class="line">                <span class="comment">// 第一次启动app的时候,不会走这个分支的</span></span><br><span class="line">                <span class="keyword">if</span> (intentActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused</span></span><br><span class="line">                    <span class="comment">// but still needs to be a lock task mode violation since the task gets</span></span><br><span class="line">                    <span class="comment">// cleared out and the device would otherwise leave the locked task.</span></span><br><span class="line">                    <span class="keyword">if</span> (isLockTaskModeViolation(intentActivity.task,</span><br><span class="line">                            (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123;</span><br><span class="line">                        showLockTaskToast();</span><br><span class="line">                        Slog.e(TAG, <span class="string">"startActivityUnchecked: Attempt to violate Lock Task Mode"</span>);</span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (r.task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        r.task = intentActivity.task;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果找到的activity所在的task的intent为null</span></span><br><span class="line">                    <span class="comment">// 这种情况发生在TaskReparenting之后，TaskReparenting之后，AMS为这个activity创建一个新的task，并将启动这个activity的Intent赋值给task.affinityIntent，并且此时的//task.Intent==null</span></span><br><span class="line">                    <span class="keyword">if</span> (intentActivity.task.intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这时要设置task的intent为要启动activity的intent</span></span><br><span class="line">                        intentActivity.task.setIntent(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 找到task所在的ActivityStack</span></span><br><span class="line">                    targetStack = intentActivity.task.stack;</span><br><span class="line">                    targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 找到当前处于前台的ActivityStack</span></span><br><span class="line">                    <span class="keyword">final</span> ActivityStack focusStack = getFocusedStack();</span><br><span class="line">                    <span class="comment">// 找到 处于前台的ActivityStack中的最顶端activity</span></span><br><span class="line">                    <span class="comment">// 实际就是编译ActivityStack中的 mTaskHistory</span></span><br><span class="line">                    <span class="comment">//  mTaskHistory中记录了该ActivityStack中最近所有的Task</span></span><br><span class="line">                    <span class="comment">// 首先遍历最近运行的Task中activity,然后找到task中顶端的activity</span></span><br><span class="line">                    ActivityRecord curTop = (focusStack == <span class="keyword">null</span>)</span><br><span class="line">                            ? <span class="keyword">null</span> : focusStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">                    <span class="keyword">boolean</span> movedToFront = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 此时判断运行在前台的activity的task是否和要启动的activity所需的task是否一致,</span></span><br><span class="line">                    <span class="comment">// 不一致的话,设置movedToFront为true,预示着需要将启动的activity所需的task调到前台</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (curTop != <span class="keyword">null</span> &amp;&amp; (curTop.task != intentActivity.task ||</span><br><span class="line">                            curTop.task != focusStack.topTask())) &#123;</span><br><span class="line">                        r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);</span><br><span class="line">                        <span class="keyword">if</span> (sourceRecord == <span class="keyword">null</span> || (sourceStack.topActivity() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                sourceStack.topActivity().task == sourceRecord.task)) &#123;</span><br><span class="line">                            <span class="comment">// We really do want to push this one into the user's face, right now.</span></span><br><span class="line">                            <span class="keyword">if</span> (launchTaskBehind &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                intentActivity.setTaskToAffiliateWith(sourceRecord.task);</span><br><span class="line">                            &#125;</span><br><span class="line">                            movedHome = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">// 将待启动的Activity的task移动到其所在的ActivityStack的最顶端</span></span><br><span class="line">                            <span class="comment">// 将ActivityStack调到前台.</span></span><br><span class="line">                            targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation,</span><br><span class="line">                                    options, r.appTimeTracker, <span class="string">"bringingFoundTaskToFront"</span>);</span><br><span class="line">                            movedToFront = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((launchFlags &amp;</span><br><span class="line">                                    (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME))</span><br><span class="line">                                    == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123;</span><br><span class="line">                                <span class="comment">// Caller wants to appear on home activity.</span></span><br><span class="line">                                intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE);</span><br><span class="line">                            &#125;</span><br><span class="line">                            options = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!movedToFront) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG_TASKS, <span class="string">"Bring to front target: "</span> + targetStack</span><br><span class="line">                                + <span class="string">" from "</span> + intentActivity);</span><br><span class="line"></span><br><span class="line">                        targetStack.moveToFront(<span class="string">"intentActivityFound"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果包含这个flag,那么需要reset task</span></span><br><span class="line">                    <span class="comment">// 就是销毁那么使用FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET(API21已经废弃取而代之的是FLAG_ACTIVITY_NEW_DOCUMENT)</span></span><br><span class="line">                    <span class="comment">// 启动的activity</span></span><br><span class="line">                    <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="comment">// 首先检查要启动的activity,也就是r中的intent中的flag是否设置FLAG_CLEAR_TASK_ON_LAUNCH,设置的话,forceReset设置为true</span></span><br><span class="line">                      <span class="comment">// 如果没有设置FLAG_ALWAYS_RETAIN_TASK_STATE,forceReset设置为true,设置的话,forceReset不做处理</span></span><br><span class="line">                      <span class="comment">// 也是就是说当FLAG_CLEAR_TASK_ON_LAUNCH和FLAG_ALWAYS_RETAIN_TASK_STATE都设置的话,引发冲突,此时忽略FLAG_ALWAYS_RETAIN_TASK_STATE</span></span><br><span class="line">                      <span class="comment">// 该方法内部会逆序索引mTaskHistory,一次和intentActivity.task做比较,一致的话,执行resetTargetTaskIfNeededLocked</span></span><br><span class="line">                      <span class="comment">// 不一致的话执行resetAffinityTaskIfNeededLocked,处理"allowTaskReparenting"的情况</span></span><br><span class="line">                      <span class="comment">// 总之该方法返回rest task之后task的顶端activity,rest时,FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET启动的activity以及在其之上的activity都会被clear,</span></span><br><span class="line">                      <span class="comment">// FLAG_ALLOW_TASK_REPARENTING启动的activity可能会被移到其他的task</span></span><br><span class="line">                      <span class="comment">// 如果新启动activity带有FLAG_FINISH_ON_TASK_LAUNCH,一律要求删除除root activity之外的所有的activity</span></span><br><span class="line">                        intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里如果startFlags中有START_FLAG_ONLY_IF_NEEDED的话，</span></span><br><span class="line">                    <span class="comment">// 表示只在需要的情况下才会启动目标，即如果被启动的对象和调用者是同一个的时候，那么就没有必要重复操作。</span></span><br><span class="line">                    <span class="comment">// 从launcher启动app不会设置这个flag</span></span><br><span class="line">                    <span class="keyword">if</span> ((startFlags &amp; ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (doResume) &#123;</span><br><span class="line">                            resumeTopActivitiesLocked(targetStack, <span class="keyword">null</span>, options);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Make sure to notify Keyguard as well if we are not running an app</span></span><br><span class="line">                            <span class="comment">// transition later.</span></span><br><span class="line">                            <span class="keyword">if</span> (!movedToFront) &#123;</span><br><span class="line">                                notifyActivityDrawnForKeyguard();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityOptions.abort(options);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123;</span><br><span class="line"></span><br><span class="line">                        reuseTask = intentActivity.task;</span><br><span class="line">                        <span class="comment">// 清除task中所以已经存在的activity</span></span><br><span class="line">                        reuseTask.performClearTaskLocked();</span><br><span class="line">                        <span class="comment">// 以启动这个新activity的intent为内容,重新设置这个task中的相关属性,</span></span><br><span class="line">                        <span class="comment">// 例如 affinity等,也就是说新启动的activity会成为这个task的root activity</span></span><br><span class="line">                        reuseTask.setIntent(r);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">                            || launchSingleInstance || launchSingleTask) &#123;</span><br><span class="line">                        <span class="comment">// 在上面if中的三个条件意味着,要清除task中要启动的activity之上的所有activity(不包括这个这个要启动的activity)</span></span><br><span class="line">                        <span class="comment">// 但是也有例外的清空,如果FLAG_ACTIVITY_CLEAR_TOP,但没设置singleTop模式而是设置了standard模式(LAUNCH_MULTIPLE),那么task中这个已经存在的要启动的</span></span><br><span class="line">                        <span class="comment">// activity实例,也会被清除,这是由下面的这个方法完成的工作,并返回可复用的activity.返回null,表示清除了这个已经存在的实例,表示不希望复用相同的activity。</span></span><br><span class="line">                        ActivityRecord top =</span><br><span class="line">                                intentActivity.task.performClearTaskLocked(r, launchFlags);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 不为null 表示找到了可复用的activity</span></span><br><span class="line">                        <span class="keyword">if</span> (top != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          <span class="comment">// 如果是root activity,还要利用新的intent修改task的相关属性</span></span><br><span class="line">                            <span class="keyword">if</span> (top.frontOfTask) &#123;</span><br><span class="line">                                top.task.setIntent(r);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT,</span><br><span class="line">                                    r, top.task);</span><br><span class="line">                            <span class="comment">// 将新intent发送给这个这个已经存在的activity实例的onNewIntent()</span></span><br><span class="line">                            top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          <span class="comment">// 为null表示清除了这个已经存在的实例,表示不希望复用相同的activity</span></span><br><span class="line">                         <span class="comment">// 设置addingToTask为true,表示需要将activity天价到可复用的task中</span></span><br><span class="line">                            addingToTask = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">// Now pretend like this activity is being started by the top of its</span></span><br><span class="line">                            <span class="comment">// task, so it is put in the right place.</span></span><br><span class="line">                            sourceRecord = intentActivity;</span><br><span class="line">                            TaskRecord task = sourceRecord.task;</span><br><span class="line">                            <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; task.stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// Target stack got cleared when we all activities were removed</span></span><br><span class="line">                                <span class="comment">// above. Go ahead and reset it.</span></span><br><span class="line">                                targetStack = computeStackFocus(sourceRecord, <span class="keyword">false</span> <span class="comment">/* newTask */</span>);</span><br><span class="line">                                targetStack.addTask(</span><br><span class="line">                                        task, !launchTaskBehind <span class="comment">/* toTop */</span>, <span class="keyword">false</span> <span class="comment">/* moving */</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// 下面的这个else  if 处理 standard和signaltop模式</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.realActivity.equals(intentActivity.task.realActivity)) &#123;</span><br><span class="line">                        <span class="comment">// 如果是signaltop模式,而且要启动的activity就是task的顶端activity,</span></span><br><span class="line">                        <span class="keyword">if</span> (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span> || launchSingleTop)</span><br><span class="line">                                &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123;</span><br><span class="line">                            ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, r,</span><br><span class="line">                                    intentActivity.task);</span><br><span class="line">                            <span class="comment">// 如果当前task顶端的activity就是其root activity,那么就要使用新的intent重新修改task的相关属性</span></span><br><span class="line">                            <span class="keyword">if</span> (intentActivity.frontOfTask) &#123;</span><br><span class="line">                                intentActivity.task.setIntent(r);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 将新intent发送给这个这个已经存在的activity实例的onNewIntent()</span></span><br><span class="line">                            intentActivity.deliverNewIntentLocked(callingUid, r.intent,</span><br><span class="line">                                    r.launchedFromPackage);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!r.intent.filterEquals(intentActivity.task.intent)) &#123;</span><br><span class="line">                            <span class="comment">// In this case we are launching the root activity</span></span><br><span class="line">                            <span class="comment">// of the task, but with a different intent.  We</span></span><br><span class="line">                            <span class="comment">// should start a new instance on top.</span></span><br><span class="line">                            <span class="comment">// 当前启动的activity和task顶端activity不一致,而且启动activity的的Intent和task的Intent不同，那么将会重新启动这个activity。</span></span><br><span class="line">                            addingToTask = <span class="keyword">true</span>;</span><br><span class="line">                            sourceRecord = intentActivity;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果启动的Intent没有设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么一定不会复用任何的activity。</span></span><br><span class="line">                        <span class="comment">// In this case an activity is being launched in to an</span></span><br><span class="line">                        <span class="comment">// existing task, without resetting that task.  This</span></span><br><span class="line">                        <span class="comment">// is typically the situation of launching an activity</span></span><br><span class="line">                        <span class="comment">// from a notification or shortcut.  We want to place</span></span><br><span class="line">                        <span class="comment">// the new activity on top of the current task.</span></span><br><span class="line">                        addingToTask = <span class="keyword">true</span>;</span><br><span class="line">                        sourceRecord = intentActivity;</span><br><span class="line">                            <span class="comment">// rootWasReset为 True if the intent at the root of the task had</span></span><br><span class="line">                            <span class="comment">// the FLAG_ACTIVITY_RESET_TASK_IF_NEEDED flag.</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!intentActivity.task.rootWasReset) &#123;</span><br><span class="line">                        <span class="comment">// In this case we are launching in to an existing task</span></span><br><span class="line">                        <span class="comment">// that has not yet been started from its front door.</span></span><br><span class="line">                        <span class="comment">// The current task has been brought to the front.</span></span><br><span class="line">                        <span class="comment">// Ideally, we'd probably like to place this new task</span></span><br><span class="line">                        <span class="comment">// at the bottom of its stack, but that's a little hard</span></span><br><span class="line">                        <span class="comment">// to do with the current organization of the code so</span></span><br><span class="line">                        <span class="comment">// for now we'll just drop it.</span></span><br><span class="line">                        intentActivity.task.setIntent(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  addingToTask为false,表示不需要创建一个新activity,也就是说找到了可复用的activity,那么</span></span><br><span class="line">                     <span class="comment">// activity的启动过程至此结束，直接调用resumeTopActivityLocked()resume top的activity即可。</span></span><br><span class="line">                    <span class="keyword">if</span> (!addingToTask &amp;&amp; reuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client</span></span><br><span class="line">                        <span class="comment">// don't use that intent!)  And for paranoia, make</span></span><br><span class="line">                        <span class="comment">// sure we have correctly resumed the top activity.</span></span><br><span class="line">                        <span class="keyword">if</span> (doResume) &#123;</span><br><span class="line">                          <span class="comment">// 显示可复用的task中的顶端activity,与要启动的activity不一致</span></span><br><span class="line">                            targetStack.resumeTopActivityLocked(<span class="keyword">null</span>, options);</span><br><span class="line">                            <span class="keyword">if</span> (!movedToFront) &#123;</span><br><span class="line">                                <span class="comment">// Make sure to notify Keyguard as well if we are not running an app</span></span><br><span class="line">                                <span class="comment">// transition later.</span></span><br><span class="line">                                notifyActivityDrawnForKeyguard();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityOptions.abort(options);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.START_TASK_TO_FRONT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码很重要,主要描述了AMS何种情况下会查找是否有可复用的task,已经可复用的task中是否有可复用的activity.如果没有可复用的activity，则需要启动一个新的activity，如果有可复用的activity，那么activity的启动过程至此结束，直接调用resumeTopActivityLocked()resume top的activity即可。</p>
<p>上面已经对代码进行了详细的注释,现在对其总结一下:</p>
<h4 id="什么情况下会去查找是否有可复用的task">什么情况下会去查找是否有可复用的task</h4><p>以下3种条件需要检查是否有有task可复用</p>
<ol>
<li><p>(launchFlags&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp;</p>
<pre><code><span class="list">(<span class="keyword">launchFlags&amp;Intent</span>.FLAG_ACTIVITY_MULTIPLE_TASK)</span> == <span class="number">0</span><span class="comment">;</span>
</code></pre></li>
<li><p>r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK</p>
</li>
<li><p>r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE</p>
</li>
</ol>
<p>Intent.FLAG_ACTIVITY_MULTIPLE_TASK不能单独使用，它是和Intent.FLAG_ACTIVITY_NEW_TASK或者FLAG_ACTIVITY_NEW_DOCUMENT结合起来使用的，如果设置了Intent.FLAG_ACTIVITY_MULTIPLE_TASK，那么将会永远启动一个新的task，不管是否有可复用的task。</p>
<h4 id="如何查找可复用的task">如何查找可复用的task</h4><ol>
<li>launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，也就是前面两个条件,遵循如下规则： findTaskLocked(r)</li>
</ol>
<p>该函数的功能是找到目标ActivityRecord,也就是要启动的activity所在的任务栈(TaskRecord)，如果找到，则返回栈顶的ActivityRecord，否则，返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">findTaskLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Looking for task of "</span> + r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (!r.isApplicationActivity() &amp;&amp; !stack.isHomeStack()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping stack: (home activity) "</span> + stack);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.mActivityContainer.isEligibleForNewTasks()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Skipping stack: (new task not allowed) "</span> +</span><br><span class="line">                        stack);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际调用ActivityStack的findTaskLocked</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord ar = stack.findTaskLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"No task found"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是ActivityStackSupervisor中定义的,其中的变量mActivityDisplays,也是ActivityStackSupervisor中定义的,是一个SparseArray<activitydisplay> 的数组,有几块屏幕,就有几个ActivityDisplay.</activitydisplay></p>
<p>ActivityDisplay类也是ActivityStackSupervisor中定义的.Android支持多屏显示，在不同的显示设备上可以有不同的ActivityStack。</p>
<p>所有的ActivityStack都是通过ActivityStackSupervisor管理起来的。 在ActivityStackSupervisor内部，设计了ActivityDisplay这个内部类，它对应到一个显示设备，默认的显示设备是手机屏幕。 ActivityStackSupervisor间接通过ActivityDisplay来维护多个ActivityStack的状态。 ActivityStack有一个属性是mStacks，当mStacks不为空时，表示ActivityStack已经绑定到了显示设备， 其实ActivityStack.mStacks只是一个副本，真正的对象在ActivityDisplay中的mStacks.</p>
<p>ActivityStackSupervisor通过变量mActivityDisplays就能间接获取所有ActivityStack的信息.</p>
<p>Activity的类型有三种：APPLICATION_ACTIVITY_TYPE(应用)、HOME_ACTIVITY_TYPE(桌面)、RECENTS_ACTIVITY_TYPE(最近使用).在ActivityRecord的构造方法中被初始化,当从launcher启动app时,肯定是APPLICATION_ACTIVITY_TYPE.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!_componentSpecified || _launchedFromUid == Process.myUid()</span><br><span class="line">                 || _launchedFromUid == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                 Intent.ACTION_MAIN.equals(_intent.getAction()) &amp;&amp;</span><br><span class="line">                 _intent.hasCategory(Intent.CATEGORY_HOME) &amp;&amp;</span><br><span class="line">                 _intent.getCategories().size() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                 _intent.getData() == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 _intent.getType() == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                 (intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 isNotResolverActivity()) &#123;</span><br><span class="line">             <span class="comment">// This sure looks like a home activity!</span></span><br><span class="line">             mActivityType = HOME_ACTIVITY_TYPE;</span><br><span class="line">             <span class="comment">// "com.android.systemui.recents"</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) &#123;</span><br><span class="line">             mActivityType = RECENTS_ACTIVITY_TYPE;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mActivityType = APPLICATION_ACTIVITY_TYPE;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>实际调用ActivityStack的findTaskLocked方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">findTaskLocked</span><span class="params">(ActivityRecord target)</span> </span>&#123;</span><br><span class="line">        Intent intent = target.intent;</span><br><span class="line">        ActivityInfo info = target.info;</span><br><span class="line">        ComponentName cls = intent.getComponent();<span class="comment">//要启动的activity的组件名:包名+类名</span></span><br><span class="line"></span><br><span class="line">       ...........</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">         .........</span><br><span class="line">         <span class="keyword">final</span> Intent taskIntent = task.intent;</span><br><span class="line">         <span class="keyword">final</span> Intent affinityIntent = task.affinityIntent;</span><br><span class="line">         ........</span><br><span class="line">         <span class="keyword">if</span> (task.rootAffinity.equals(target.taskAffinity)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_TASKS) Slog.d(TAG, <span class="string">"Found matching affinity!"</span>);</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span> (taskIntent != <span class="keyword">null</span> &amp;&amp; taskIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                taskIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Objects.equals(documentData, taskDocumentData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (affinityIntent != <span class="keyword">null</span> &amp;&amp; affinityIntent.getComponent() != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                affinityIntent.getComponent().compareTo(cls) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                Objects.equals(documentData, taskDocumentData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">       ............</span><br></pre></td></tr></table></figure>
<p>总的来说,这种情况下遵循如下规则:</p>
<p>遍历所有显示设备中的ActivityStack(一般情况下,只有一个显示设备)中的所有TaskRecord:</p>
<p>a. 查找ActivityStack中的mTaskHistory是否有与要启动的activity相同affinity的task，找到的话返回,返回这个task顶端的activity</p>
<p>这里要说明下,TaskRecord中有两个关于affinity的属性,如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String affinity;        <span class="comment">// The affinity name for this task, or null; may change identity.</span></span><br><span class="line">String rootAffinity;    <span class="comment">// Initial base affinity, or null; does not change from initial root.</span></span><br></pre></td></tr></table></figure>
<p>两者的区别代码注释也很清晰了,rootAffinity和affinity是存储创建这个task时,activity的taskAffinity.当rest 这个task的时候,可能会修改task的affinity,但是不会修改rootAffinity.</p>
<p>b.  如果activity没有affinity，即属性android:taskAffinity设置为“”，空字符串时。此时AMS就会去mHistory中去查找是否有task的root activity和启动的activity相同，通过比较task.intent.getComponent()和启动activity的Comeponent比较</p>
<p>c.如果task.Intent为空，这种情况发生在TaskReparenting之后，TaskReparenting之后，AMS为这个activity创建一个新的task，并将启动这个activity的Intent赋值给task.affinityIntent，并且此时的task.Intent==null。此时就需要比较task.affinityIntent.getComponent()和启动activity的Comeponent比较，看是否和启动的activity相同</p>
<p> 以上3个规则中，均是返回找的task中最上面的activity，而不一定是要启动的activity，至于如何处理要启动的activity和task中已有的activity，后面会介绍。</p>
<ol>
<li>launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE的情况，遵循如下规则： findActivityLocked(intent, r.info)</li>
</ol>
<p>根据Intent和ActivityInfo这两个参数可以获取一个Activity的包名，该函数会从栈顶至栈底遍历ActivityStack中的所有Activity，如果包名匹配成功，就返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">findActivityLocked</span><span class="params">(Intent intent, ActivityInfo info)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">         <span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">             <span class="keyword">final</span> ActivityRecord ar = stacks.get(stackNdx).findActivityLocked(intent, info);</span><br><span class="line">             <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> ar;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">findActivityLocked</span><span class="params">(Intent intent, ActivityInfo info)</span> </span>&#123;</span><br><span class="line">    ComponentName cls = intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (info.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cls = <span class="keyword">new</span> ComponentName(info.packageName, info.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">        TaskRecord task = mTaskHistory.get(taskNdx);</span><br><span class="line">        <span class="keyword">if</span> (!isCurrentProfileLocked(task.userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; activities = task.mActivities;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> activityNdx = activities.size() - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) &#123;</span><br><span class="line">            ActivityRecord r = activities.get(activityNdx);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式来说，它所处的task中只允许有它一个activity，因此它的规则只符合上面规则中的b.</p>
<p>对于规则a，由于设置了ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity，它只能自己独处一个task，不可能和别人共享同一个task，因此ActivityStack中的mTaskHistory即使存在了与该activity有相同的affinity的activity，如果这个activity和启动的activity不同，那么ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity也不可能和它共用一个task，因此这规则a完全可以不用检查。</p>
<p>对于规则b，由于该模式的activity独处一个task，因此完全没有可能所处的task的affinity和自己的affinity不同，因此，假如ActivityStack中的mTaskHistory存在相同的activity与启动的activity相同，那么这个activity的affinity必然和自己的相同。所以对于这种模式，规则b囊括了其他模式的规则a,b。</p>
<p>对于规则c，同样的道理，ActivityInfo.LAUNCH_SINGLE_INSTANCE启动模式的activity不可能处在与自己不同affinity的task中，因此不可能出现TaskReparenting操作，所以这条也不需要。</p>
<h4 id="如何处理找到的可复用的task">如何处理找到的可复用的task</h4><p>首先得到当前前台的activity,以从launcher启动app这个场景来说,当前前台activity就是home.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityStack lastStack = getLastStack();</span><br><span class="line">ActivityRecord curTop = lastStack == <span class="keyword">null</span>?</span><br><span class="line">                            <span class="keyword">null</span> : lastStack.topRunningNonDelayedActivityLocked(notTop);</span><br></pre></td></tr></table></figure>
<p>接着判断urTop.task != intentActivity.task,其实说白了,就是为了确定当前的task是否就是要启动的activity所在的task,不是的话调用</p>
<p>targetStack.moveTaskToFrontLocked()方法,该方法会调用insertTaskAtTop()方法将task移动其所在的ActivityStack的顶端,然后调用moveToFront()方法将这个Activity移动到前台.也就是预示着要启动的activity所在的task被移动到了前台.</p>
<h4 id="将task移动到前台后检查是否需要rest_task">将task移动到前台后检查是否需要rest task</h4><p>如果启动activity的flag设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED,则需要进行rest task.</p>
<p>最常见的情况，当从Home启动应用程序时，会设置这个flag；从recently task进入应用程序，则不会设置这个falg。</p>
<p>设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，AMS会对复用的task作如下处理:</p>
<p>⑴ 对于复用task中的除root activity外的activity，有如下处理</p>
<p>在此之前，先介绍activity的几个关键属性(task的root  activity 设置了下面所提的属性的话,task也就具备了这样的特性)：</p>
<p> ① 如果复用task在后台时间超过一定的时间，那么在这个过程中将clear除root activity之外的所有的activity；</p>
<p> ② 如果新启动的activity设置了属性ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE，那么表明不需要clear task中的activity；</p>
<p> ③ 如果新启动的activity设置了属性ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH，那么表明只要task离开前台，一律要求删除除root activity之外的所有的activity；</p>
<p> ④ 复用task中的activity设置了属性ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH，那么复用task从home中再次被启动到前台时，这个activity会被删除；</p>
<p> ⑤ 复用task中的activity设置了属性ActivityInfo.FLAG_ALLOW_TASK_REPARENTIN，并且这个activity的resultTo为空，那么也就是说这个activity和它的caller没有依赖关系，需要对其进行TaskReparenting操作</p>
<p> ⑥ 复用task中的activity的Intent设置属性Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET，那么下次再从home中进入到task中，那么将删除设置了该属性的activity以上所有的activity，例如A–&gt;B–&gt;C–&gt;D–&gt;E,假如在C启动D时设置了该属性，那么下次从HOME中再次进入到这个task中时，将会是A–&gt;B–&gt;C。</p>
<p> ⑦ 如果复用task中的activity的resultTo不为空，也就是启动这个activity的是一个activity，那么这个activity的处理将按照它的前一个activity的处理方式来处理，不管在何时情况下，它的前一个activity都是启动它的activity，即便resultTo不是前一个activity，如设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT。如果复用task中每个activity的resultTo都不为空，并且上述处理优先级在其前面的属性没有设置的话，那么这个复用task中的activity将不作任何的处理。</p>
<p>  一般情况下，activity的resultTo都不为空，除非设置了Intent.FLAG_ACTIVITY_FORWARD_RESULT，那么此时被启动的activity的caller的resultTo将会为空。</p>
<p> task中的activity的属性设置是上述属性的组合，因此reset task过程要按照一定的优先级来处理，上述属性的处理优先级是：⑥=④&gt;⑦&gt;⑤&gt;③=②&gt;①</p>
<p> 具体操作顺序如下：</p>
<ol>
<li>根据⑥，④条件来删除复用task中相应的activity；</li>
</ol>
<p>2 .条件下，将会暂时不做处理，再根据它的前一个activity的属性来做处理，即使这个activity设置了allowTaskReparenting；</p>
<ol>
<li><p>如果activity的resultTo为空，并且满足条件⑤，那么将其及其以上未作处理的，满足条件⑦的所有activity，一并进行TaskReparenting操作，并放置在mHistory栈底。它们在mHistory栈底顺序如同在复用task中的顺序；</p>
</li>
<li><p>根据①②③的条件来删除复用task中相应的activity。</p>
</li>
</ol>
<p>⑵ 不属于复用task的activity，并且它的resultTo不为空，那么将根据它的前一个activity的处理来处理；</p>
<p>⑶ 不属于复用task，但是和当前启动的activity有相同affinity，并且允许TaskReparenting操作，那么将进行以下操作：</p>
<p> 如果满足上述的①②③④的条件，但是其中的task不是复用task，而是这个activity所处的task，那么将输出这个activity，而不是进行TaskReparenting操作。</p>
<p>为什么非复用task中的activity，和当前启动的activity有相同affinity，并且允许TaskReparenting操作，满足了①②③④的条件之后要删除呢，为什么非复用task中的其他activity，不需要删除呢？</p>
<p>正因为它和启动的activity有相同的affinity，因此AMS认为这个activity是和启动activity相关的，以后可能会重新调用，所以当其满足删除条件后,这时它将不允许TaskReparenting操作，并且不应该再允许它存在于其他的task中，此时应该删除。</p>
<p>如果没有满足①②③④的条件，那么将会对其进行TaskReparenting操作，重新将其移动到复用task或新启动的task中。</p>
<h4 id="判断可复用的task中是否有可复用的activity">判断可复用的task中是否有可复用的activity</h4><p> (1)Intent设置了Intent.FLAG_ACTIVITY_CLEAR_TOP，或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK，或者r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE；这3种条件有一个共同点，就是启动的activity启动之后，在这个task中,这个activity之上不能有其他的activity。</p>
<p> 一般情况下，需要将复用task中启动的activity之上的所有的activity删除，</p>
<p>当activity的launchMode == ActivityInfo.LAUNCH_MULTIPLE，即standard模式，并且Intent并未要求singletop模式，这种情况是连复用task中与启动activity相同的activity都要删除，也就是不希望复用相同的activity。</p>
<p>performClearTaskLocked()实现了上述功能，并返回可复用的activity。</p>
<p>如果有可复用的activity，并且这个activity是task的root activity，由于task的Intent是root activity的Intent，所以需要重新设置task的Intent。</p>
<p>向可复用的activity发送新的Intent，通知它Intent的变化，最终会调用到这个activity的onNewIntent()方法。</p>
<p>如果没找到可复用的activity,那么设置addingToTask = true;sourceRecord = intentActivity;</p>
<p>⑵ 如果不满足⑴条件的话，但是启动的activity与复用task的root activity相同。</p>
<p>如果此时Intent设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，并且复用task的top activity正好是要启动的activity，则复用这个activity，同时更新activity的Intent，如果需要更新task的Intent。</p>
<p>如果Intent没有设置了Intent.FLAG_ACTIVITY_SINGLE_TOP，即使设置了，但是当前的top activity不是正要启动的activity，那么会判断当前启动的Intent和task的Intent不同，那么将会重新启动这个activity。</p>
<p> 其他情况，将直接resume top的activity(不是要启动的activity)。</p>
<p> ⑶ 如果⑴ ⑵条件均不满足，其实如果不满足⑴ ⑵条件的话，复用的task中就不存在与启动的activity相同的activity了，如果启动的Intent没有设置Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么一定不会复用任何的activity。</p>
<p> (4) 如果⑴ ⑵条件均不满足，并且Intent设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED，那么需要检查当前复用task的Intent是否设置了Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。如果没有设置，重新设置新的Intent,这种情况下同样不可能复用activity,因为task中不存在与启动的activity相同的activity。</p>
<p>在4这种情况,当复用的task中没有找到要启动的activity的时候，将不会显示要启动的activity，addingToTask为false,而是改为显示复用的task中顶端的activity.比如从launcher中启动app,随便进入app中的另一个activity中,然后按home健,然后在点击app图标,如果刚刚进入的activity没有设置FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET,那么将显示这个activity而不是app的主activity.</p>
<p>至此，整个Task复用，以及activity复用的过程就介绍完了，如果没有可复用的activity，且没没有可复用的task则需要启动一个新的activity，或者有可复用的task但是没设置FLAG_ACTIVITY_RESET_TASK_IF_NEEDED,也要重启动一个新的activity,但是如果有可复用的activity而且设置了FLAG_ACTIVITY_RESET_TASK_IF_NEEDED,则不会启动要启动的activity,而是启动可复用task的顶端的task.</p>
<h4 id="singleTop和singleTask属性的处理">singleTop和singleTask属性的处理</h4><p>余下代码是针对singleTop和singleTask属性的处理，前面分析Task复用的时候，也有对singleTop和singleTask属性的处理，两者有什么不同呢？</p>
<p>前面是在有可复用task的前提下分析的.</p>
<p>接下来分析都是在没有可复用task前提下.</p>
<p>当设置Intent.FLAG_ACTIVITY_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TOP或者launchMode == ActivityInfo.LAUNCH_SINGLE_TASK这几种情况下，如果top activity与启动的activity为同一个activity，那么将复用top activity，并直接resume top activity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ActivityStack topStack = getFocusedStack();</span><br><span class="line">           ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);</span><br><span class="line">           <span class="keyword">if</span> (top != <span class="keyword">null</span> &amp;&amp; r.resultTo == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 如果顶端activity就是要启动activity,那就启动顶端的就可以了</span></span><br><span class="line">               <span class="keyword">if</span> (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">                           || launchSingleTop || launchSingleTask) &#123;</span><br><span class="line">                           ActivityStack.logStartActivity(EventLogTags.AM_NEW_INTENT, top,</span><br><span class="line">                                   top.task);</span><br><span class="line">                           <span class="comment">// For paranoia, make sure we have correctly</span></span><br><span class="line">                           <span class="comment">// resumed the top activity.</span></span><br><span class="line">                           topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="keyword">if</span> (doResume) &#123;</span><br><span class="line">                               resumeTopActivitiesLocked();</span><br><span class="line">                           &#125;</span><br><span class="line">                           ActivityOptions.abort(options);</span><br><span class="line">                           <span class="keyword">if</span> ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// We don't need to start a new activity, and</span></span><br><span class="line">                               <span class="comment">// the client said not to do anything if that</span></span><br><span class="line">                               <span class="comment">// is the case, so this is it!</span></span><br><span class="line">                               <span class="keyword">return</span> ActivityManager.START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">                           &#125;</span><br><span class="line">                           top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage);</span><br><span class="line">                           <span class="keyword">return</span> ActivityManager.START_DELIVERED_TO_TOP;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>, r.resultTo, r.resultWho,</span><br><span class="line">                        r.requestCode, Activity.RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>  r.resultTo == null这个条件是在startActivityForResult()的requestCode&lt;0时成立。</p>
<h4 id="standard和singleInstance模式">standard和singleInstance模式</h4><p>没有可复用的task,那么必须要创建新的task吗? 不一定!!!</p>
<p>比如说从一个app中的一个activity启动另外一个app的一个activity,如果没有添加FLAG_ACTIVITY_NEW_TASK,那么这个activity就会添加到当前的task中.如果有FLAG_ACTIVITY_NEW_TASK,则会新创建一个task.</p>
<p>第一次从桌面启动app时,是有这个标记的,所以会新创建一个task.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Should this be considered a new task?</span></span><br><span class="line"><span class="comment">// 如果有可复用的task,addingToTask为true</span></span><br><span class="line">        <span class="keyword">if</span> (r.resultTo == <span class="keyword">null</span> &amp;&amp; inTask == <span class="keyword">null</span> &amp;&amp; !addingToTask</span><br><span class="line">                &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          .....</span><br><span class="line">          newTask = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 找到一个合适的ActivityStack</span></span><br><span class="line">          targetStack = computeStackFocus(r, newTask);</span><br><span class="line">          <span class="comment">// 确保放在ActivityStack中的mstacks的尾端也就是栈顶端.</span></span><br><span class="line">          <span class="comment">// 实际上是ActivityDisplay.mstakcks</span></span><br><span class="line">          <span class="comment">// 也就是确保找到的这个ActivityStack调整到当前显示屏幕的顶端</span></span><br><span class="line">          <span class="comment">// 如果targetStack和homestack处于同一个屏幕中时,要调用ActivityStackSupervisor.moveHomeStack方法</span></span><br><span class="line">          <span class="comment">// 因为要启动新的activity了(在没有分屏时,都符合这种情况)</span></span><br><span class="line">          targetStack.moveToFront(<span class="string">"startingNewTask"</span>);</span><br><span class="line">          .....</span><br><span class="line">          <span class="comment">// reuseTask两情况下不为null,一是intask不为null,也就是说从最近任务列表启动;</span></span><br><span class="line">          <span class="comment">// 二是有可复用task,但是设置有FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_CLEAR_TASK</span></span><br><span class="line">          f (reuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建Task的同时,会把task加入到activityStack中,launchTaskBehind为false,那么这个task通过insertTaskAtTop加入到activitystack的顶端</span></span><br><span class="line">            <span class="comment">// 也就是mTaskHistory的末尾</span></span><br><span class="line">                    r.setTask(targetStack.createTaskRecord(getNextTaskId(),</span><br><span class="line">                            newTaskInfo != <span class="keyword">null</span> ? newTaskInfo : r.info,</span><br><span class="line">                            newTaskIntent != <span class="keyword">null</span> ? newTaskIntent : intent,</span><br><span class="line">                            voiceSession, voiceInteractor, !launchTaskBehind <span class="comment">/* toTop */</span>),</span><br><span class="line">                            taskToAffiliate);</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_TASKS) Slog.v(TAG, <span class="string">"Starting new activity "</span> + r + <span class="string">" in new task "</span> +</span><br><span class="line">                            r.task);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r.setTask(reuseTask, taskToAffiliate);</span><br><span class="line">                &#125;</span><br><span class="line">          .....</span><br><span class="line"></span><br><span class="line">          mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName,</span><br><span class="line">                       intent, r.getUriPermissionsLocked(), r.userId);</span><br><span class="line">          ..........</span><br><span class="line">          targetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 调用startActivityLocked继续启动activity</span></span><br><span class="line">      targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">      <span class="keyword">if</span> (!launchTaskBehind) &#123;</span><br><span class="line">          <span class="comment">// Don't set focus on an activity that's going to the back.</span></span><br><span class="line">          mService.setFocusedActivityLocked(r, <span class="string">"startedActivity"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ActivityManager.START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里需要强调一下computeStackFocus这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">ActivityStack <span class="title">computeStackFocus</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask)</span></span>&#123;</span><br><span class="line">...........</span><br><span class="line"><span class="keyword">if</span> (mFocusedStack != mHomeStack &amp;&amp; (!newTask ||</span><br><span class="line">                mFocusedStack.mActivityContainer.isEligibleForNewTasks())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG_FOCUS,</span><br><span class="line">                    <span class="string">"computeStackFocus: Have a focused stack="</span> + mFocusedStack);</span><br><span class="line">            <span class="keyword">return</span> mFocusedStack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; homeDisplayStacks = mHomeStack.mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = homeDisplayStacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            stack = homeDisplayStacks.get(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isHomeStack()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG_FOCUS,</span><br><span class="line">                        <span class="string">"computeStackFocus: Setting focused stack="</span> + stack);</span><br><span class="line">                <span class="keyword">return</span> stack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// Need to create an app stack for this user.</span></span><br><span class="line"> stack = createStackOnDisplay(getNextStackId(), Display.DEFAULT_DISPLAY);</span><br><span class="line"> <span class="keyword">if</span> (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG_FOCUS, <span class="string">"computeStackFocus: New stack r="</span></span><br><span class="line">         + r + <span class="string">" stackId="</span> + stack.mStackId);</span><br><span class="line"> <span class="keyword">return</span> stack;</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当没有启动过app,例如刚开机时,那么mFocusedStack就是mHomeStack.</p>
<p>此时如果从launcher中启动一个app,那么就会调用createStackOnDisplay,创建一个 ActivityStack供运行众多的app使用的ActivityStack.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextStackId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (++mLastStackId &lt;= HOME_STACK_ID) &#123;</span><br><span class="line">               mLastStackId = HOME_STACK_ID + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (getStack(mLastStackId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mLastStackId;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 在显示屏幕中创建ActivityStack</span></span><br><span class="line">    <span class="function">ActivityStack <span class="title">createStackOnDisplay</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        ActivityDisplay activityDisplay = mActivityDisplays.get(displayId);</span><br><span class="line">        <span class="keyword">if</span> (activityDisplay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相当于创建了一个ActivityStack</span></span><br><span class="line">        ActivityContainer activityContainer = <span class="keyword">new</span> ActivityContainer(stackId);</span><br><span class="line">        mActivityContainers.put(stackId, activityContainer);</span><br><span class="line">        <span class="comment">// 将ActivityStack与activityDisplay绑定</span></span><br><span class="line">        activityContainer.attachToDisplayLocked(activityDisplay);</span><br><span class="line">        <span class="keyword">return</span> activityContainer.mStack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachToDisplayLocked</span><span class="params">(ActivityDisplay activityDisplay)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_STACK) Slog.d(TAG_STACK, <span class="string">"attachToDisplayLocked: "</span> + <span class="keyword">this</span></span><br><span class="line">                       + <span class="string">" to display="</span> + activityDisplay);</span><br><span class="line">               <span class="comment">// ActivityStack绑定的显示屏幕</span></span><br><span class="line">               mActivityDisplay = activityDisplay;</span><br><span class="line">               <span class="comment">// ActivityStack绑定的显示屏幕的id</span></span><br><span class="line">               mStack.mDisplayId = activityDisplay.mDisplayId;</span><br><span class="line">               <span class="comment">// ActivityStack中的mstack来自于activityDisplay.mStacks</span></span><br><span class="line">               <span class="comment">// ActivityStack.mstack记录的是与之绑定的显示屏幕中的其他ActivityStack</span></span><br><span class="line">               mStack.mStacks = activityDisplay.mStacks;</span><br><span class="line">               <span class="comment">// 将此ActivityStack加入到显示屏也就是ActivityDisplay.mStacks中</span></span><br><span class="line">               <span class="comment">// ActivityDisplay.mStacks记录的是这个快屏幕中所有的ActivityStack</span></span><br><span class="line">               <span class="comment">// 此时,ActivityStack.mstack也包括了自己.</span></span><br><span class="line">               activityDisplay.attachActivities(mStack);</span><br><span class="line">               mWindowManager.attachStack(mStackId, activityDisplay.mDisplayId);</span><br><span class="line">           &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">attachActivities</span><span class="params">(ActivityStack stack)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (DEBUG_STACK) Slog.v(TAG_STACK,</span><br><span class="line">                     <span class="string">"attachActivities: attaching "</span> + stack + <span class="string">" to displayId="</span> + mDisplayId);</span><br><span class="line">             mStacks.add(stack);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>activityDisplay代表一个显示屏幕,activityContainer是ActivityStack的马甲.</p>
<p>当从launcnher启动过一个app之后,按home键回到桌面,此时mFocusedStack被设置为mHomeStack.但是第一次从launcher启动app的时候,创建了ActivityStack并且执行了attachToDisplayLocked()方法.</p>
<p>在该方法中执行了activityDisplay.attachActivities(mStack);将创建的ActivityStack加入到了显示屏幕(默认为DEFAULT_DISPLAY)中mStacks中.mHomeStack也是一个ActivityStack,绑定的显示屏幕是DEFAULT_DISPLAY.代码中注释也说了,ActivityStack的mStacks记录的是与之绑定的显示屏幕中的所有ActivityStack.自然也包括前面创建的app stack 了.</p>
<p>所以启动另一个app时执行:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到DEFAULT_DISPLAY屏幕绑定的所有ActivityStack</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; homeDisplayStacks = mHomeStack.mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = homeDisplayStacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">          stack = homeDisplayStacks.get(stackNdx);</span><br><span class="line">            <span class="comment">// 找到一个不是mHomeStack的ActivityStack并返回</span></span><br><span class="line">            <span class="comment">// 当之前在这个快屏幕中创建过一个app stack时,就返回这个stack.</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isHomeStack()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FOCUS || DEBUG_STACK) Slog.d(TAG_FOCUS,</span><br><span class="line">                        <span class="string">"computeStackFocus: Setting focused stack="</span> + stack);</span><br><span class="line">                <span class="keyword">return</span> stack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>⑴ 设置了Intent.FLAG_ACTIVITY_NEW_TASK，则为该activity创建一个新的task；</p>
<p>上述贴出的代码是从launcher启动app时的代码的流程,未贴出的代码总结如下:</p>
<p>⑵ 在当前的task中启动新的activity，</p>
<pre><code><span class="comment">①当前的caller是一个activity，如果设置Intent</span><span class="string">.</span><span class="comment">FLAG_ACTIVITY_CLEAR_TOP，当前的task如果存在要启动的activity(这个和上一节中的Task复用时的clear</span> <span class="comment">top过程不同，两者是互斥的过程，不冲突)，清除其上的所有的activity；</span>

<span class="comment">②</span> <span class="comment">当前的caller是一个activity，如果设置Intent</span><span class="string">.</span><span class="comment">FLAG_ACTIVITY_REORDER_TO_FRONT，这个flag表示如果启动的activity已经在当前的task中，那么如果当前启动的Intent设置了该flag，那么则会将这个activity从task中移动到top。</span>

     <span class="comment">如果A</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">B</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">C</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">D，D启动B时，设置了该flag，那么将变为A</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">C</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">D</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">B</span>

     <span class="comment">①②两个条件，则不需要再启动新的activity，直接resume</span> <span class="comment">top。</span>

<span class="comment">③</span>  <span class="comment">当前的caller是一个activity，其他情况则需要启动新的activity。</span>
</code></pre><p>⑶ 当前的caller不是activity，那么仍将新启动的activity放在top的task中。  </p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/22/Android_ActivityManagerService-8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Android6.0之AMS启动app中篇之创建app进程
        
      </div>
    </a>
  
  
    <a href="/2016/07/07/Android_ActivityManagerService-6/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android6.0之Activity的管理与启动模式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Android_ActivityManagerService-7" data-title="Android6.0之AMS如何启动app中篇之Task的管理" data-url="http://www.iloveandroid.net/2016/07/11/Android_ActivityManagerService-7/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"iloveandroid"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 genglei.cuan
   <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256335558'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256335558%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> 
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>