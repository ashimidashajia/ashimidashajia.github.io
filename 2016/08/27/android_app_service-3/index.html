<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android6.0之App的Service组件运行机制之bindService | 码农故事</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="现在来分析bindService的具体过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android6.0之App的Service组件运行机制之bindService">
<meta property="og:url" content="http://www.iloveandroid.net/2016/08/27/android_app_service-3/index.html">
<meta property="og:site_name" content="码农故事">
<meta property="og:description" content="现在来分析bindService的具体过程。">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2780242-c11bbd267ebbd52a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2780242-f6bd08149f4f01a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2780242-52921787ad1c7e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-08-30T11:50:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android6.0之App的Service组件运行机制之bindService">
<meta name="twitter:description" content="现在来分析bindService的具体过程。">
  
    <link rel="alternative" href="/atom.xml" title="码农故事" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">genglei.cuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不断成长的见证</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/linux基础">linux基础</a></li>
				        
							<li><a href="/categories/Android底层开发">Android底层开发</a></li>
				        
							<li><a href="/categories/App开发">App开发</a></li>
				        
							<li><a href="/categories/项目管理">项目管理</a></li>
				        
							<li><a href="/categories/Python">Python</a></li>
				        
							<li><a href="/categories/开源框架">开源框架</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android刷机/" style="font-size: 10px;">Android刷机</a> <a href="/tags/Android底层/" style="font-size: 10px;">Android底层</a> <a href="/tags/Android核心服务/" style="font-size: 20px;">Android核心服务</a> <a href="/tags/Android编译/" style="font-size: 11.43px;">Android编译</a> <a href="/tags/Gradle/" style="font-size: 15.71px;">Gradle</a> <a href="/tags/linux常用命令/" style="font-size: 10px;">linux常用命令</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/代码管理/" style="font-size: 18.57px;">代码管理</a> <a href="/tags/应用开发/" style="font-size: 10px;">应用开发</a> <a href="/tags/提高效率/" style="font-size: 10px;">提高效率</a> <a href="/tags/构建/" style="font-size: 15.71px;">构建</a> <a href="/tags/签名认证/" style="font-size: 11.43px;">签名认证</a> <a href="/tags/自动化测试/" style="font-size: 14.29px;">自动化测试</a> <a href="/tags/调试/" style="font-size: 12.86px;">调试</a> <a href="/tags/逆向工程/" style="font-size: 17.14px;">逆向工程</a> <a href="/tags/逆向开发/" style="font-size: 18.57px;">逆向开发</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">码农的成长之路，不要让昨日的悲伤，浪费今天的眼泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">genglei.cuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">genglei.cuan</h1>
			</hgroup>
			
			<p class="header-subtitle">不断成长的见证</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/linux基础">linux基础</a></li>
		        
					<li><a href="/categories/Android底层开发">Android底层开发</a></li>
		        
					<li><a href="/categories/App开发">App开发</a></li>
		        
					<li><a href="/categories/项目管理">项目管理</a></li>
		        
					<li><a href="/categories/Python">Python</a></li>
		        
					<li><a href="/categories/开源框架">开源框架</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-android_app_service-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/27/android_app_service-3/" class="article-date">
  	<time datetime="2016-08-27T09:26:23.000Z" itemprop="datePublished">2016-08-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android6.0之App的Service组件运行机制之bindService
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android核心服务/">Android核心服务</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android底层开发/">Android底层开发</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在来分析bindService的具体过程。</p>
<a id="more"></a>
<h3 id="简述">简述</h3><p>bindService的过程要比startService的过程复杂一些，因为bingService之后，发起者可以跨进程调用service的某些方法。而startService启动service之后，发起者仅能去终止service，而不能调用service的方法。</p>
<p>既然发起者可以跨进程调用service中的方法，那么肯定要用到binder了。本文也会重点分析binder的传递过程，至于binder的机制，后面在单独开篇介绍。使用bindService启动的service的开发过程中一般都会借助aidl。这里不介绍aidl，因为这不是本文的重点。</p>
<p>当一个app进程bindService()时，它需要先准备好一个实现了ServiceConnection接口的对象。ServiceConnection的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindService()见名知意即绑定服务，建立一个逻辑连接。当连接建立之后，绑定也就完成了，AMS会回调ServiceConnection接口对象的onServiceConnected()方法。把远端service的代理binder传递过来，这样就可以通过这个代理binder跨进程调用service中的方法了。</p>
<p>ServiceConnection接口的onServiceDisconnected()方法并不会在unbindService()操作断开逻辑连接时执行。而是在远端service进程终止时，AMS才会回调onServiceDisconnected()。</p>
<p>另外要注意的是纵然service进程的因为某些原因被终止，之前的绑定在该service上的逻辑连接仍处于激活状态，当service再次运行的时候，AMS会回调onServiceConnected。</p>
<p>bindService的过程，我们要关心的binder有两个，一个是远端service的binder，有了它客户端进程才能跨进程调用service中的方法；另一个是binder是客户端传递给AMS的，有了这个binder，AMS才会在逻辑连接建立之后，跨进程调用客户端中的ServiceConnection接口的对象中的onServiceConnected()和onServiceDisconnected()。</p>
<p>要明白bindservice的过程，就必须搞清楚这两个binder的传递过程他。</p>
<p>另外bindservice在建立连接时，如果发现service还没启动，会根据flag是否设置BIND_AUTO_CREATE，决定是否启动这个service。</p>
<p>同startService()一样，bindService()也是一个异步的过程，也就是说当该方法返回时，逻辑连接很可能还没有建立，通俗的说就是该方法返回时，onServiceConnected()方法很可能还没执行。</p>
<h3 id="app的service和系统的service">app的service和系统的service</h3><p>系统中的servcice都是由ServiceManager负责管理的。系统中的service在启动的时候，都会向ServiceManager注册。</p>
<p>App进程要使用这些系统service时，比如AMS，可以向ServiceManager通过service名字查询。ServiceManager会返回这个service的一个代理binder。这样便可以向service发起调用请求了。</p>
<p>但是app是没有权限向ServiceManager注册service的。所以只能另辟蹊径。bindService要负责找到service的代理binder并传递到app进程。这期间涉及到binder实体的跨进程传输，也就是所谓的匿名binder。因为这些binder并没有在ServiceManager中注册。</p>
<h3 id="bindService的过程">bindService的过程</h3><p>整个过程大体上是这样的：</p>
<ol>
<li><p>检查要绑定的额service是否启动，没有的话，要先启动service，然后执行service的生命周期方法。</p>
</li>
<li><p>执行绑定，先将远端service的binder传递到AMS中，然后AMS在将其传递到客户端组件进程中</p>
</li>
</ol>
<p>ContextImpl.bindService():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> bindServiceCommon(service, conn, flags, Process.myUserHandle());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ContextImpl.bindServiceCommon():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span><br><span class="line">            UserHandle user)</span> </span>&#123;</span><br><span class="line">        IServiceConnection sd;</span><br><span class="line">      ................</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//从LoadedApk中拿到一个binder实体</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                    mMainThread.getHandler(), flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  Android5.0之后不允许使用隐式调用</span></span><br><span class="line">        <span class="comment">// 这里对传入的intetn进行检查，如果是android5.0以上，</span></span><br><span class="line">        <span class="comment">//是隐式intent的话抛出异常</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IBinder token = getActivityToken();</span><br><span class="line">            ....................</span><br><span class="line">            service.prepareToLeaveProcess();</span><br><span class="line">            <span class="comment">// 向AMS发起跨进程调用其bindService方法</span></span><br><span class="line">            <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">          ..............................</span><br><span class="line">            <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里便引出了第一个binder：IServiceConnection sd。这是一个实体binder，也就是说跨进程传输到AMS进程之后，AMS进程中最终得到的是一个代理binder。而且binder实体跨进程传输过程中，会在binder驱动层中为其创建相应的数据结构，这样binder便在binder驱动中扎根了。</p>
<p>那么这个客户端进程中的binder实体最初是从哪里来的呢？</p>
<h4 id="客户端组件中用来调度绑定操作的ServiceDispatcher对象">客户端组件中用来调度绑定操作的ServiceDispatcher对象</h4><p>此处的mPackageInfo是用户进程里和apk对应的LoadedApk对象，前面所说的第一个binder实体由LoadedApk.getServiceDispatcher()获得:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span><br><span class="line">        Context context, Handler handler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 先从LoadedApk.mService中查找，</span></span><br><span class="line">        <span class="comment">// 看看发起绑定操作的组件是否已经存在一个用来处理传入的ServiceConnection接口对象的ServiceDispatcher</span></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 存在的话直接返回这个ServiceDispatcher</span></span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不存在的话创建一个ServiceDispatcher</span></span><br><span class="line">            <span class="comment">// 这里要注意第三个参数handler，是主线程的handler</span></span><br><span class="line">            <span class="comment">// 保存在了ServiceDispatcher.mActivityThread中</span></span><br><span class="line">            sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将创建的ServiceDispatcher缓存到LoadedApk.mService</span></span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadedApk.ServiceDispatcher从它的名字中可以看出它类似于一个Dispatcher的作用，这个类的作用就是当客户端 bind某个service成功之后，负责向客户端分配service IBinder的；以及当客户端unbind service时，负责通知客户端 unbind service的状态。</p>
<p>对于ServiceDispatcher的管理，是以apk，即package为载体的，也就是说对于某个package，定义在其中的component如果请求去bind一个service，那么LoadedApk将为这个component分配一个ServiceDispatcher。</p>
<p>component每请求bind一个service，都会为其指定一个ServiceConnection接口的对象，同一component组件内，LoadedApk将会为这个ServiceConnection接口的对象分配一个唯一的ServiceDispatcher。但是不同component组件中，就算是使用同一个ServiceConnection接口的对象，LoadedApk中也会为这个对象分配两个ServiceDispatcher对象。</p>
<p>也就是说，ServiceDispatcher是客户端组件相关的一个概念。</p>
<p>每个app进程中是可以加载多个apk包的，记录在ActivityThread.mPackages,整个关系如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2780242-c11bbd267ebbd52a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android_app_service-6.png"></p>
<p>packages中的组件component，例如某个activity中使用bindService去绑定一个service时，都需要提供一个实现ServiceConnection接口的对象，每一个这样的对象都会与一个ServiceDispatcher对象绑定。</p>
<p>LoadedApk.mServices中存储了本package中所有组件中所有的ServiceDispatcher。它是一个ArrayMap，key是context，实际上就是组件，因为组件继承自Context。value又是一个ArrayMap，因为一个组件中使可以绑定多个service的嘛。这个map的可以是实现了ServiceConnection接口的对象，value是与之绑定的ServiceDispatcher对象。</p>
<p>现在可以看看这个ServiceDispatcher到底是个什么东东了，特别关注它的属性成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个binder实体对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDispatcher.InnerConnection mIServiceConnection;</span><br><span class="line">    <span class="comment">// 逻辑连接建立时，执行的回调接口对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mConnection;</span><br><span class="line">    <span class="comment">// 所在的组件，即client</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="comment">// 进程主线程即UI线程中的handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mActivityThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnectionLeaked mLocation;</span><br><span class="line">    <span class="comment">// 绑定service时，传入的flag，例如BIND_AUTO_CREATE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimeException mUnbindLocation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDied;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mForgotten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections</span><br><span class="line">       = <span class="keyword">new</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();</span><br><span class="line">................</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ServiceDispatcher.InnerConnection是一个继承自 IServiceConnection.Stub的binder实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">            InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">                mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">                LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">                <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sd.connected(name, service);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ServiceDispatcher.connected():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mActivityThread是主线程的handler</span></span><br><span class="line">    <span class="comment">// 也就是说，实际上ServiceConnection中的回调是在主线程中执行的</span></span><br><span class="line">      <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          doConnected(name, service);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从其名字上来看InnerConnection是一个内部连接，该怎么理解呢？</p>
<p>因为bindService()传递的ServiceConnection接口对象，并没有跨进程传输到AMS中，从bindServiceCommon()方法可以看出最终传递到AMS的是LoadedApk.getServiceDispatcher()返回的ServiceDispatcher.InnerConnection。AMS通过它跨进程间接调用ServiceConnection中的方法。</p>
<p>因为一个ServiceConnection可以在同一个客户端组件内被bindService方法多次调用，用来绑定不同的service，那么ServiceDispatcher中自然要存储这些使用同一个serviceConnection绑定的service的连接信息了——ServiceDispatcher.mActiveConnections。</p>
<p>它是ArrayMap<componentname, servicedispatcher.connectioninfo="">类型对象，</componentname,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 远端service的代理binder</span></span><br><span class="line">  IBinder binder;</span><br><span class="line">  <span class="comment">// 远端service 死亡通知回调</span></span><br><span class="line">  IBinder.DeathRecipient deathMonitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AMS中绑定service过程">AMS中绑定service过程</h2><p>ContextImpl.bindServiceCommon()方法中得到ServiceConnection对应的ServiceDispatcher对象之后，便向AMS发起请求，跨进程调用AMS.bindService()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span><br><span class="line">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line"></span><br><span class="line">    ..............</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// mServices是ActiveService</span></span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS.bindService()对参数做了简单检查之后，又调用ActiveService.bindServiceLocked()方法。</p>
<p>这里先对ActiveService.bindServiceLocked()方法的几个重要参数做一些说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(</span><br><span class="line">         IApplicationThread caller, // 客户端进程ActivityThread.mAppThread的代理binder</span><br><span class="line">         IBinder token,</span><br><span class="line">         Intent service,// 客户端绑定service时的intent</span><br><span class="line">         String resolvedType,</span><br><span class="line">         IServiceConnection connection, //客户端进程的中ServiceDispatcher.InnerConnection的代理binder</span><br><span class="line">         <span class="keyword">int</span> flags,</span><br><span class="line">         String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>ActiveService.bindServiceLocked()与上一篇介绍的startService的ActiveService.startServiceLocked()方法中有很多相似的逻辑。</p>
<p>比如同样是要先查找要启动的servicee在AMS中的代表ServiceRecord是否存在，存在的话，意味着service已经启动；不存在的话，要创建一个ServiceRecord对象，这些操作还是由retrieveServiceLocked()方法负责的。然后通过bringUpServiceLocked()调用service的生命周期方法。只不过bindservice,除了这两个基本操作外，还要执行绑定操作，即将service的binder传跨进程传输到app客户端组件中。</p>
<h3 id="绑定前的准备工作">绑定前的准备工作</h3><p>执行绑定操作前，要先做一些准备工作，比如在AMS中记录客户端和service的一些信息，下面的代码就是做这些事情的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">           String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">           String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">  ...............</span><br><span class="line">  <span class="comment">// 得到service对应的ServiceRecord</span></span><br><span class="line">  ServiceLookupResult res =</span><br><span class="line">      retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">              Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">  ServiceRecord s = res.record;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// 根据传入的intent和发起者进程，查找到一个合适的AppBindRecord对象，</span></span><br><span class="line">  <span class="comment">// 查找不到就创建一个，下面会介绍规则</span></span><br><span class="line">  AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">  <span class="comment">// 为本次连接创建ConnectionRecord对象</span></span><br><span class="line">  ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">          connection, flags, clientLabel, clientIntent);</span><br><span class="line">  <span class="comment">// 客户端进程的中ServiceDispatcher.InnerConnection的代理binder</span></span><br><span class="line">  IBinder binder = connection.asBinder();</span><br><span class="line">  <span class="comment">// 将创建的逻辑连接对象ConnectionRecord，记录在ServiceRecord中</span></span><br><span class="line">  ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">  <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">      clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">      s.connections.put(binder, clist);</span><br><span class="line">  &#125;</span><br><span class="line">  clist.add(c);</span><br><span class="line">  <span class="comment">// 同时记录在AppBindRecord.connections中</span></span><br><span class="line">  b.connections.add(c);</span><br><span class="line">  <span class="comment">// AppBindRecord.client是ProcessRecord,代表客户端的进程</span></span><br><span class="line">  b.client.connections.add(c);</span><br><span class="line">  .......</span><br><span class="line">  <span class="comment">// 除了ServiceRecord.connections记录了该service连接信息外</span></span><br><span class="line">  <span class="comment">// ActiveService.mServiceConnections记录了当前系统中所有的连接信息</span></span><br><span class="line">  <span class="comment">// 所以也要将创建的连接对象，加入ActiveService.mServiceConnections</span></span><br><span class="line">  clist = mServiceConnections.get(binder);</span><br><span class="line">  <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">      clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">      mServiceConnections.put(binder, clist);</span><br><span class="line">  &#125;</span><br><span class="line">  clist.add(c);</span><br><span class="line">............</span><br></pre></td></tr></table></figure>
<p>在前面关于service机制介绍的文章中提到过ServiceRecord中有一些数据成员是bindservice时用到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRecord</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">    ...............</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;();</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections</span><br><span class="line">                = <span class="keyword">new</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt;();<span class="comment">// IBinder -&gt; ConnectionRecord of all bound clients</span></span><br><span class="line">    <span class="comment">// service所在的进程</span></span><br><span class="line">    ProcessRecord app;      <span class="comment">// where this service is running or null.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AMS描述绑定service时的intent的IntentBindRecord类">AMS描述绑定service时的intent的IntentBindRecord类</h4><p>app客户端组件中发起绑定service操作时，一定要用到intent，一般是显示的intent（android 5.0 之后要求必须是显示intent），而且只设置intetn.mComponent字段。</p>
<p>AMS中对绑定操作传入的intent是用Intent.FilterComparison类来描述,也就是说当客户端绑定service时使用的intent指定的参数都一致的话，AMS会将其看做是同一类intent。</p>
<p>AMS会为这类intent为其创建一个IntentBindRecord对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentBindRecord</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定的service在AMS中的代表</span></span><br><span class="line">    <span class="keyword">final</span> ServiceRecord service;</span><br><span class="line">    <span class="comment">/** The intent that is bound.*/</span></span><br><span class="line">    <span class="keyword">final</span> Intent.FilterComparison intent; <span class="comment">//</span></span><br><span class="line">    <span class="comment">/** All apps that have bound to this Intent. */</span></span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt;();</span><br><span class="line">    <span class="comment">// service的binder代理binder</span></span><br><span class="line">    IBinder binder;</span><br></pre></td></tr></table></figure>
<p>其中IntentBindRecord.service 最终会保存绑定的service的ServiceRecord；</p>
<p>IntentBindRecord.intent 就是前面所说的绑定service时设定的参数一致的intent在AMS中的表示Intent.FilterComparison对象；</p>
<p>IntentBindRecord.apps用来记录所有使用该类intetn绑定同一个service的客户端信息。key是客户端进程ProcessRecord，value是AppBindRecord。因为不同的客户端可能使用相同的intent参数来绑定同一个service,所以IntentBindRecord要记录下这些客户端信息；</p>
<p>IntentBindRecord.binder最终保存service的代理binder；</p>
<p>AMS通过ServiceRecord.retrieveAppBindingLocked()方法为判断是否为传入的intent创建一个IntentBindRecord：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppBindRecord <span class="title">retrieveAppBindingLocked</span><span class="params">(</span><br><span class="line">           Intent intent,// 客户端发起绑定操作时传入的intent</span><br><span class="line">           ProcessRecord app // 客户端组件进程)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 为传入的intent创建一个Intent.FilterComparison</span></span><br><span class="line">       Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">       <span class="comment">// 查找传入的intent是否已经有IntentBindRecord</span></span><br><span class="line">       IntentBindRecord i = bindings.get(filter);</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 没有的话创建</span></span><br><span class="line">           i = <span class="keyword">new</span> IntentBindRecord(<span class="keyword">this</span>, filter);</span><br><span class="line">           <span class="comment">//并缓存到ServiceRecord.bings中</span></span><br><span class="line">           bindings.put(filter, i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 查找客户端的组件是否已经绑定过该service</span></span><br><span class="line">       AppBindRecord a = i.apps.get(app);</span><br><span class="line">       <span class="comment">// 绑定过的话，返回找到的AppBindRecord</span></span><br><span class="line">       <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 没有的话创建一个AppBindRecord对象</span></span><br><span class="line">       a = <span class="keyword">new</span> AppBindRecord(<span class="keyword">this</span>, i, app);</span><br><span class="line">       <span class="comment">// 并缓存到IntentBindRecord.apps中</span></span><br><span class="line">       i.apps.put(app, a);</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>retrieveAppBindingLocked()另一个主要作用是查找并创建AppBindRecord对象。</p>
<h4 id="AMS用于描述绑定service的客户端整体信息的AppBindRecord类">AMS用于描述绑定service的客户端整体信息的AppBindRecord类</h4><p>对于一个Service来说，有多少app客户端进程和它建立了绑定关系，就会有多少个AppBindRecord对象。一个app客户端进程里可以有多个地方发起绑定动作，所以AppBindRecord里需要用一个ArraySet<connectionrecord>记录下每个绑定动作对应的逻辑连接对象。</connectionrecord></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBindRecord</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所在的service</span></span><br><span class="line">    <span class="keyword">final</span> ServiceRecord service;    <span class="comment">// The running service.</span></span><br><span class="line">    <span class="comment">// 客户端发起的bindservice时传入的intent，AMS会为其创建一个对应的IntentBindRecord</span></span><br><span class="line">    <span class="keyword">final</span> IntentBindRecord intent;  <span class="comment">// The intent we are bound to.</span></span><br><span class="line">    <span class="comment">// 客户端进程</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord client;     <span class="comment">// Who has started/bound the service.</span></span><br><span class="line">    <span class="comment">// 客户端所在的app，其他组件绑定该service的逻辑连接</span></span><br><span class="line">    <span class="keyword">final</span> ArraySet&lt;ConnectionRecord&gt; connections = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line">                                    <span class="comment">// All ConnectionRecord for this client.</span></span><br></pre></td></tr></table></figure>
<p>AppBindRecord.service 用于描述客户端绑定的service；</p>
<p>AppBindRecord.intent 用于描述客户端绑定该service时使用的intent；</p>
<p>AppBindRecord.client 用于描述客户端的进程；</p>
<p>AppBindRecord.connections 用于描述客户端中所有组件绑定该service时创建的逻辑连接；</p>
<p>AMS通过ServiceRecord.retrieveAppBindingLocked()来查找并创建一个合适的AppBindRecord对象。</p>
<h4 id="描述绑定连接的ConnectionRecord类">描述绑定连接的ConnectionRecord类</h4><p>AMS为每次绑定过程中创建的连接分配一个ConnectionRecord类型对象.</p>
<p>ConnectionRecord用来描述一个连接信息，即绑定信息，要对客户端和service端进行描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* Description of a single binding to a service.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRecord</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录客户端绑定的信息</span></span><br><span class="line">   <span class="keyword">final</span> AppBindRecord binding;    <span class="comment">// The application/service binding.</span></span><br><span class="line">   <span class="comment">// 这里是绑定服务的客户端的一个binder，通过它可以调用客户端的方法</span></span><br><span class="line">   <span class="comment">// ServiceConnection.onServiceConnected()</span></span><br><span class="line">   <span class="keyword">final</span> IServiceConnection conn;  <span class="comment">// The client connection.</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> flags;                <span class="comment">// Binding options.</span></span><br></pre></td></tr></table></figure>
<p>ConnectionRecord.binding代表这个连接所在的AppBindRecord.</p>
<p>ConnectionRecord.coon是一个binder代理对象，其实体binder是app进程中ServiceDispatcher.mIServiceConnection。用来回调客户端进程中当连接成功建立时的回调方法。</p>
<p>客户端组件在bindservice时，都要创建一个实现ServiceConnection接口的对象，每个这样的对象在客户端组件所在的LoadedApk中都会分配一个ServiceDispatcher对象，这个对象用于处理所有使用该ServiceConnection接口的对象绑定service的客户端组件的回调方法的执行。</p>
<p>ConnectionRecord.flags 用于描述绑定该service时，指定的flags，例如BIND_AUTO_CREATE.</p>
<p>AMS创建的ConnectionRecord对象会存储在ServiceRecord.connections成员变量中.</p>
<p>ServiceRecord.connections是一个map，key是ServiceDispatcher.InnerConnection的代理binder，value是ArrayList<connectionrecord>类型的。</connectionrecord></p>
<p>因为客户端进程中一个Component中可能使用同一个ServiceConnection接口对象来多次绑定同一个service，因为每次绑定都会创建一个ConnectionRecord对象，那么这些ConnectionRecord需要使用ArrayList<connectionrecord>来保存。</connectionrecord></p>
<p>value中ConnectionRecord.IServiceConnection实际上一致与key是一致的。</p>
<p>AMS除了将这个”逻辑连接”ConnectionRecord对象，记录在ServiceRecord.connections中外，还要向至少下面的几处位置做记录：</p>
<ol>
<li><p>客户端所在的进程在AMS中的代表ProcessRecord.connections</p>
</li>
<li><p>ActiveService.mServiceConnections,这里面记录了AMS中所有app的service的连接</p>
</li>
<li><p>AppBindRecord.connections中</p>
</li>
</ol>
<p>之所以要在这么多地方做记录，可能是为了在不同的场合下迅速查找到连接吧。</p>
<p>了解了以上内容后，就可以通过下图简明的描述客户端进程和AMS之间的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2780242-f6bd08149f4f01a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android_app_service-7.png"></p>
<h4 id="执行service生命周期方法">执行service生命周期方法</h4><p>在做好前面的准备工作之后，binderservice()就开始准备与Service建立连接了。那么自然要先对service进行一些操作，说白了就是执行service的生命周期方法，这是由bringUpServiceLocked()方法来负责的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">           String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">           String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">.................</span><br><span class="line"><span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">    s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">// 只有当要绑定的service所在的进程还启动的时候，该方法返回非null</span></span><br><span class="line">    <span class="comment">// 因为启动进程需要一段时间，所以就要先退出来</span></span><br><span class="line">    <span class="comment">// 这里暂时假设service所在的进程已经启动</span></span><br><span class="line">    <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....................</span><br></pre></td></tr></table></figure>
<p>此时可以分为两大情况：</p>
<ol>
<li><p>service进程还没启动</p>
</li>
<li><p>service进程已经启动，此时有可分为两种情况：service还没启动和service已经运行。</p>
</li>
</ol>
<p>bringUpServiceLocked()方法依据ServiceRecord.app区分以上两大情况：</p>
<ol>
<li>ServiceRecord.app不为null，而且ServiceRecord.app.thread也不为null，预示着service已经运行了，但是这时候并不会向startService()启动service那样跨进程调用service.onStartCommand()生命周期方法，因为bindService启动service时没有将信息记录到ServiceRecord.pendingStarts。</li>
</ol>
<ol>
<li>ServiceRecord.app为null，说明ServiceRecord还没有和service所在的进程关联。</li>
</ol>
<p>此时在依据ServiceRecord.processName,也就是service要求运行在的进程的名字，在AMS中查找是否有这样的进程存在，如果有的话，只需要启动service，也就是在找到的进程中创建service对象，并执行service.onCreate()生命周期方法。</p>
<p>以上两种情况的详细过程，参考前一篇文章。</p>
<p>如果没有在AMS中找到名字为ServiceRecord.processName的进程，那么就要先创建进程了，这里不考虑这种情况。</p>
<h4 id="绑定service">绑定service</h4><p>绑定实际上就是想办法拿到service的binder，并将其传递到客户端组件进程，另外还要对前面准备工作期间创建的数据结构设置相关的字段。</p>
<p>这部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">           String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">           String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">.................</span><br><span class="line"><span class="comment">// b为AppBindRecord</span></span><br><span class="line"><span class="comment">// b.intent.received为true，表明已经拿到了客户端已经绑定过了，</span></span><br><span class="line"><span class="comment">// 所以已经拿到了service的binder</span></span><br><span class="line">f (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">        <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">        <span class="comment">// publish the connection.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就可以直接远程调用客户端组件中onServiceConnected()方法将service的binder传递过去了</span></span><br><span class="line">            c.conn.connected(s.name, b.intent.binder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failure sending service "</span> + s.shortName</span><br><span class="line">                    + <span class="string">" to connection "</span> + c.conn.asBinder()</span><br><span class="line">                    + <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">        <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">        <span class="comment">// rebound, then do so.</span></span><br><span class="line">        <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">        <span class="comment">// 之前没绑定过，那么就调用下面的额方法进行绑定</span></span><br><span class="line">        requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getServiceMap(s.userId).ensureNotStartingBackground(s);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分两种情况（前提service已经运行了）：</p>
<ol>
<li><p>客户端某个组件之前已经绑定过该service，客户端的其他组件又要绑定该service</p>
</li>
<li><p>客户端组件首次绑定该service</p>
</li>
</ol>
<p>这两种情况的区分是依据AppBindRecord.intent，即AMS为bindservice()传入的intent分配的IntentBindRecord对象来决定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentBindRecord</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Binder published from service. */</span></span><br><span class="line">  IBinder binder;</span><br><span class="line">  <span class="comment">/** Set when we have initiated a request for this binder. */</span></span><br><span class="line">  <span class="keyword">boolean</span> requested;</span><br><span class="line">  <span class="comment">/** Set when we have received the requested binder. */</span></span><br><span class="line">  <span class="keyword">boolean</span> received;</span><br><span class="line">  <span class="comment">/** Set when we still need to tell the service all clients are unbound. */</span></span><br><span class="line">  <span class="keyword">boolean</span> hasBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntentBindRecord.received为true，表明IntentBindRecord.binder已经指向远端service的binder；</p>
<p>IntentBindRecord.requested为false，表明IntentBindRecord.binder还没有指向远端service的binder；</p>
<p>这里分析第二种情况，时序图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2780242-52921787ad1c7e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="android_app_service-9.png"></p>
<p>requestServiceBindingLocked()方法中跨进程调用service所在的进程中方法，最终会导致service.onBind()执行，该方法返回service的实体binder。</p>
<p>这里有一点要贴别注意，那只要service被某个客户端组件绑定过了，就不会再执行service.onBind()方法了，原因就在requestServiceBindingLocked()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ..............</span><br><span class="line">        <span class="comment">// 传入的rebind为false还是true，取决于AMS调用service.onUnbind()返回值</span></span><br><span class="line">        <span class="comment">// 如果希望客户端下一次绑定到服务时接收 onRebind() 调用（而不是接收 onBind() 调用），onUnbind()返回true</span></span><br><span class="line">        <span class="comment">// service首次被绑定时，rebind肯定为false</span></span><br><span class="line">        <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">                <span class="comment">// 跨进程调用service所在进程的scheduleBindService()方法，执行绑定操作，这是一个异步方法，会立即返回</span></span><br><span class="line">                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                        r.app.repProcState);</span><br><span class="line">                <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                    <span class="comment">// 只要service被绑定过了，IntentBindRecord.requested就会被设置为true</span></span><br><span class="line">                    i.requested = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">                i.doRebind = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">              .................</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">              .................</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可知，只要service被绑定过一次，那么IntentBindRecord.requested救回被设置为true，其他客户端组件再次绑定的时候，由于if条件为假，所以不会再次跨进程调用service进程中的scheduleBindService()方法，也就不会调用service.onBind()方法了。</p>
<p>因为bindservice时传入的intent一般都是显示intent，不会设置其他参数，所以只要客户端绑定的是同一个service，那么在AMS中只会有一个IntentBindRecord对象。</p>
<p>除非该servcie绑定过之后，所有绑定它的客户端组件都执行了unbindService()，那么最终会导致service.onUnbind()方法执行，如果该方法返回了true，那么下次再有客户端组件绑定该service时，rebind会被设置为true，这导致不会调用service.onBind()，而是调用service.rebind（）方法。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">        Service s = mServices.get(data.token);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">            Slog.v(TAG, <span class="string">"handleBindService s="</span> + s + <span class="string">" rebind="</span> + data.rebind);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.intent.prepareToEnterProcess();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 传入flase时执行onBind()</span></span><br><span class="line">                    <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                        IBinder binder = s.onBind(data.intent);</span><br><span class="line">                        ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                                data.token, data.intent, binder);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 传入true时执行onRebind()</span></span><br><span class="line">                        s.onRebind(data.intent);</span><br><span class="line">                        ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                            + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里考虑首次绑定时的情况，所以rebind肯定为false，那么service调用过onBind()之后，又通过AMS的代理，跨进程调用AMS的publishService()将service的binder传递到AMS中，然后在传递到客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">.......</span><br><span class="line">IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line"><span class="comment">// 初次绑定</span></span><br><span class="line"><span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">      <span class="comment">// 保存service的代理binder</span></span><br><span class="line">      b.binder = service;</span><br><span class="line">      <span class="comment">// 设置下面的两个标志为true</span></span><br><span class="line">      b.requested = <span class="keyword">true</span>;</span><br><span class="line">      b.received = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 一般情况下，首次绑定时，connections.size为1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">           ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">               ConnectionRecord c = clist.get(i);</span><br><span class="line">               <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                           TAG_SERVICE, <span class="string">"Not publishing to: "</span> + c);</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                           TAG_SERVICE, <span class="string">"Bound intent: "</span> + c.binding.intent.intent);</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                           TAG_SERVICE, <span class="string">"Published intent: "</span> + intent);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Publishing to: "</span> + c);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 将service的binder传递到客户端</span></span><br><span class="line">                   c.conn.connected(r.name, service);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   Slog.w(TAG, <span class="string">"Failure sending service "</span> + r.name +</span><br><span class="line">                         <span class="string">" to connection "</span> + c.conn.asBinder() +</span><br><span class="line">                         <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>
<p>那么当首次绑定之后，又有其他客户端组件来绑定这个service，那么在bindServiceLocked()方法中，会直接跨进程调用客户端的connected()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">        ................</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">              <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">              <span class="comment">// publish the connection.</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 直接跨进程调用客户端的connected()</span></span><br><span class="line">                  <span class="comment">// 不在需要跨进程调用service.onBind()</span></span><br><span class="line">                  c.conn.connected(s.name, b.intent.binder);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  Slog.w(TAG, <span class="string">"Failure sending service "</span> + s.shortName</span><br><span class="line">                          + <span class="string">" to connection "</span> + c.conn.asBinder()</span><br><span class="line">                          + <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">        ..........................</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看客户端进程的connected()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// 先得到处理ServiceConnection的ServiceDispatcher</span></span><br><span class="line">    LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sd.connected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// mActivityThread是在创建 ServiceDispatcher对象时，传入的组件所在进程的主线程的handler</span></span><br><span class="line">   <span class="comment">// 也就是说RunConnection是在组件所在的主线程中执行的</span></span><br><span class="line">   <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">       mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       doConnected(name, service);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunConnection.run()中会调用LoadedApk.doConnected()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">        doConnected(mName, mService);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">        doDeath(mName, mService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadedApk.doConnected()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        .....................</span><br><span class="line">        ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">        <span class="comment">//很有意思，也就是说同一组件中对同一个service重复绑定，onServiceConnected()只会执行一次</span></span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">              <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">                  <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            mDied = <span class="keyword">false</span>;</span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置死亡回调</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 将info保存在LoadedApk.mActiveConnections</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is not disconnected.</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 执行回调</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doConnected()比较有意思的是下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">old = mActiveConnections.get(name);</span><br><span class="line">      <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">          <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mActiveConnections来自ServiceDispatcher：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt; mActiveConnections</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;ComponentName, ServiceDispatcher.ConnectionInfo&gt;();</span><br></pre></td></tr></table></figure>
<p>ServiceDispatcher.mActiveConnections用来记录该LoadedApk中的组件所绑定的service的连接信息。key是service的组件名，value是ServiceDispatcher.ConnectionInfo。</p>
<p>ConnectionInfo中记录了service的代理binder以及死亡通知回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 远端service的代理binder</span></span><br><span class="line">  IBinder binder;</span><br><span class="line">  <span class="comment">// 远端service 死亡通知回调</span></span><br><span class="line">  IBinder.DeathRecipient deathMonitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connected(ComponentName name, IBinder service)方法的第一个参数是service的组件名，第二个参数是service的代理binder。</p>
<p>connected()方法中首先以name为key在mActiveConnections查找，如果索引到的ConnectionInfo的binder与传入的binder一致的话，说明是同一组件内使用同一个ServiceConnection接口对象对同一个service重复绑定，此时不会执行onServiceConnected()方法。</p>
<h3 id="unbindeService">unbindeService</h3><p>现在在看一下unbindeService()的过程，直接看AMS.unbindServiceLocked()，整个过程大体上就是找到相关的连接对象ConnectionRecord,将其从相关的map中移除，然后根据情况决定是否调用serive.onUnbind生命周期方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 得到ServiceDispatcher.InnerConnection的binder</span></span><br><span class="line">       IBinder binder = connection.asBinder();</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"unbindService: conn="</span> + binder);</span><br><span class="line">       <span class="comment">// 前面说了ActiveService.mServiceConnections,这里面记录了AMS中所有app的service的连接</span></span><br><span class="line">       <span class="comment">// 自然也包括同一组件内使用同一个ServiceConnection绑定同一个service的情况</span></span><br><span class="line">       ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">       <span class="comment">// 说明没有使用该ServiceConnection接口对象绑定过service</span></span><br><span class="line">       <span class="comment">// 所以无需unbind</span></span><br><span class="line">       <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Slog.w(TAG, <span class="string">"Unbind failed: could not find connection for "</span></span><br><span class="line">                 + connection.asBinder());</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 依次取出同一组件内使用该ServiceConnection接口对象绑定的service的连接信息对象ConnectionRecord</span></span><br><span class="line">           <span class="comment">// 这里要注意的是，这相当于在发起unbindService()操作的组件中，对所有使用该ServiceConnection接口对象绑定的sercvice</span></span><br><span class="line">           <span class="comment">// 发起unbindService操作</span></span><br><span class="line">           <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               ConnectionRecord r = clist.get(<span class="number">0</span>);</span><br><span class="line">               removeConnectionLocked(r, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                   <span class="comment">// In case it didn't get removed above, do it now.</span></span><br><span class="line">                   Slog.wtf(TAG, <span class="string">"Connection "</span> + r + <span class="string">" not removed for binder "</span> + binder);</span><br><span class="line">                   clist.remove(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                   <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                       r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                       mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                               r.binding.service.app.hasClientActivities</span><br><span class="line">                               || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   mAm.updateOomAdjLocked(r.binding.service.app);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           Binder.restoreCallingIdentity(origId);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再看removeConnectionLocked():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConnectionLocked</span><span class="params">(</span><br><span class="line">    ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct)</span> </span>&#123;</span><br><span class="line">    IBinder binder = c.conn.asBinder();</span><br><span class="line">    AppBindRecord b = c.binding;</span><br><span class="line">    ServiceRecord s = b.service;</span><br><span class="line">    <span class="comment">// 从ServiceRecord中取出所有绑定该service的连接</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将使用要unbindService()的ServiceConnection创建的连接</span></span><br><span class="line">        <span class="comment">// 从ServiceRecord.connections中移除</span></span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.connections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将使用要unbindService()的ServiceConnection创建的连接</span></span><br><span class="line">    <span class="comment">// 从AppBindRecord.connections中移除</span></span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="keyword">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.activity.connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.activity.connections.remove(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.updateHasAboveClientLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将使用要unbindService()的ServiceConnection创建的连接</span></span><br><span class="line">        <span class="comment">// 从ActiveService.mServiceConnections中移除</span></span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果AppBindRecord.connections.size为0</span></span><br><span class="line">    <span class="comment">// 表示某客户端已经没有组件与该service绑定了</span></span><br><span class="line">    <span class="comment">// 那么将客户端从IntentBindRecord.apps中移除</span></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Disconnecting binding "</span> + b.intent</span><br><span class="line">                + <span class="string">": shouldUnbind="</span> + b.intent.hasBound);</span><br><span class="line">        <span class="comment">// 如果IntentBindRecord.apps.size为0，表示没有客户端与该service绑定了</span></span><br><span class="line">        <span class="comment">// 那么开始回调service进程的scheduleUnbindService（），执行service.unbind()</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">                    <span class="comment">// If this service's process is not already in the cached list,</span></span><br><span class="line">                    <span class="comment">// then update it in the LRU list here because this may be causing</span></span><br><span class="line">                    <span class="comment">// it to go down there and we want it to start out near the top.</span></span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(s.app);</span><br><span class="line">                b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn't want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when unbinding service "</span> + s.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();</span><br><span class="line">            <span class="keyword">if</span> (!hasAutoCreate) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s.tracker.setBound(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            SystemClock.uptimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据情况决定是否调用service.onDestroy()方法</span></span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="keyword">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleUnbindService（）会导致下面的方法在service的主线程中执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUnbindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">        Service s = mServices.get(data.token);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.intent.prepareToEnterProcess();</span><br><span class="line">                <span class="comment">// 执行service.onUnbind()生命周期方法</span></span><br><span class="line">                <span class="keyword">boolean</span> doRebind = s.onUnbind(data.intent);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                        <span class="comment">// 如果onUnbind()的返回值设置为true的话，</span></span><br><span class="line">                        <span class="comment">// 调用AMS.unbindFinished()</span></span><br><span class="line">                        ActivityManagerNative.getDefault().unbindFinished(</span><br><span class="line">                                data.token, data.intent, doRebind);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to unbind to service "</span> + s</span><br><span class="line">                            + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>unbindeService（）代码就说道这里，接下来总结下：</p>
<ol>
<li><p>ServiceConnection.onServiceDisconnected()并不会在unbindeService()过程中调用，它只会在service进程被终止时回调通知绑定的客户端；</p>
</li>
<li><p>只有在绑定这个service的所有客户端中的组件都执行了unbindeService()时，service才会被销毁，执行servcice.onDestroy(),这也就要求暗示我们当完成于服务的交互后，最好unbindeService,这样有利于系统及时回收service资源；</p>
</li>
<li><p>当目标service所在的进程被杀掉时(即除了正常回收service)，系统并不会销毁之前的与该service绑定的组件创建的连接，一旦service后续再次运行，系统会再次回调onServiceConnected()；</p>
</li>
<li><p>如果service是通过startService（）启动的，那么service将一直运行到其通过 stopSelf() 自行停止，或其他组件调用 stopService() 为止，无论其是否绑定到任何客户端；</p>
</li>
<li><p>unbindeService()操作也是异步操作的；</p>
</li>
<li><p>一般情况下，只要service被客户端绑定过了，当其再被绑定时，不会在调用service.onBind()方法了，也就是说通常service.onBind()只会执行一次；</p>
</li>
<li><p>同一个组件内使用同一个ServiceConnection接口对象，重复绑定一个service时，会在AMS中为起创建连接，但是不会导致ServiceConnection.onServiceConnected()方法执行</p>
</li>
<li><p>同一个组件内执行unbindeService(ServiceConnection sc)时，相当于对所有使用sc绑定的service执行一次unbindeService操作；</p>
</li>
</ol>
<p>这里比较有趣的是，假设同一组件内使用sc重复绑定的一个servcie N次，那么这一次unbindeService(),当对于该该组件绑定该service来说执行了N次unbindeService操作。</p>
<p>生命周期的总结：</p>
<p>单独使用bindService()，unbindService()会经历：-&gt;onCreate()-&gt;onBind()-&gt;Service running-&gt;onUnbind() -&gt; onDestroy()；</p>
<p>单独使用startService()，stopService()会经历：-&gt;onCreate()-&gt;onStartCommand()-&gt;Service running-&gt; onDestroy()；</p>
<p>先调用startService()，再调用bindService()方法：</p>
<p>a. 如果结束只调用unbindService()，那么只会执行到onUnbind()，将不会执行onDestroy()：-&gt;onCreate()-&gt;onStartCommand()-&gt;onBind()-&gt;Service running-&gt; onUnbind();</p>
<p>b. 如果在unbindService后，在调用stopService()，那么：-&gt;onCreate()-&gt;onStartCommand()-&gt;onBind()-&gt;Service running-&gt; onUnbind()-&gt;onDestroy();</p>
<p>service的生命周期方法都运行在主线程中，所以如果要在生命周期中执行耗时操作，请额外开启线程。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/07/android_binder_1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          初探Android中的binder机制
        
      </div>
    </a>
  
  
    <a href="/2016/08/26/android_app_service-2/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android6.0之App的Service组件运行机制之StartService</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android_app_service-3" data-title="Android6.0之App的Service组件运行机制之bindService" data-url="http://www.iloveandroid.net/2016/08/27/android_app_service-3/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"iloveandroid"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 genglei.cuan
   <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256335558'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256335558%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> 
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>