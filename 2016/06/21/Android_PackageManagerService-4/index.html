<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android-6.0之PMS解析中篇1 | 码农故事</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本篇文章主要介绍PMS扫描和解析APK文件。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-6.0之PMS解析中篇1">
<meta property="og:url" content="http://www.iloveandroid.net/2016/06/21/Android_PackageManagerService-4/index.html">
<meta property="og:site_name" content="码农故事">
<meta property="og:description" content="本篇文章主要介绍PMS扫描和解析APK文件。">
<meta property="og:updated_time" content="2016-06-21T11:15:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android-6.0之PMS解析中篇1">
<meta name="twitter:description" content="本篇文章主要介绍PMS扫描和解析APK文件。">
  
    <link rel="alternative" href="/atom.xml" title="码农故事" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">genglei.cuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不断成长的见证</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/linux基础">linux基础</a></li>
				        
							<li><a href="/categories/Android底层开发">Android底层开发</a></li>
				        
							<li><a href="/categories/App开发">App开发</a></li>
				        
							<li><a href="/categories/项目管理">项目管理</a></li>
				        
							<li><a href="/categories/Python">Python</a></li>
				        
							<li><a href="/categories/开源框架">开源框架</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android刷机/" style="font-size: 10px;">Android刷机</a> <a href="/tags/Android底层/" style="font-size: 10px;">Android底层</a> <a href="/tags/Android核心服务/" style="font-size: 20px;">Android核心服务</a> <a href="/tags/Android编译/" style="font-size: 11.43px;">Android编译</a> <a href="/tags/Gradle/" style="font-size: 15.71px;">Gradle</a> <a href="/tags/linux常用命令/" style="font-size: 10px;">linux常用命令</a> <a href="/tags/uml/" style="font-size: 10px;">uml</a> <a href="/tags/代码管理/" style="font-size: 18.57px;">代码管理</a> <a href="/tags/应用开发/" style="font-size: 10px;">应用开发</a> <a href="/tags/提高效率/" style="font-size: 10px;">提高效率</a> <a href="/tags/构建/" style="font-size: 15.71px;">构建</a> <a href="/tags/签名认证/" style="font-size: 11.43px;">签名认证</a> <a href="/tags/自动化测试/" style="font-size: 14.29px;">自动化测试</a> <a href="/tags/调试/" style="font-size: 12.86px;">调试</a> <a href="/tags/逆向工程/" style="font-size: 17.14px;">逆向工程</a> <a href="/tags/逆向开发/" style="font-size: 18.57px;">逆向开发</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">码农的成长之路，不要让昨日的悲伤，浪费今天的眼泪。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">genglei.cuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xj6ce.com1.z0.glb.clouddn.com/android.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">genglei.cuan</h1>
			</hgroup>
			
			<p class="header-subtitle">不断成长的见证</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/linux基础">linux基础</a></li>
		        
					<li><a href="/categories/Android底层开发">Android底层开发</a></li>
		        
					<li><a href="/categories/App开发">App开发</a></li>
		        
					<li><a href="/categories/项目管理">项目管理</a></li>
		        
					<li><a href="/categories/Python">Python</a></li>
		        
					<li><a href="/categories/开源框架">开源框架</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Android_PackageManagerService-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/21/Android_PackageManagerService-4/" class="article-date">
  	<time datetime="2016-06-21T07:16:35.000Z" itemprop="datePublished">2016-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android-6.0之PMS解析中篇1
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android核心服务/">Android核心服务</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android底层开发/">Android底层开发</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要介绍PMS扫描和解析APK文件。</p>
<a id="more"></a>
<p>继续分析PMS的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">Process.THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">mHandlerThread.start();</span><br><span class="line">mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line"></span><br><span class="line">File dataDir = Environment.getDataDirectory();</span><br><span class="line">mAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"data"</span>);</span><br><span class="line">mAppInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app"</span>);</span><br><span class="line">mAppLib32InstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-lib"</span>);</span><br><span class="line">mAsecInternalPath = <span class="keyword">new</span> File(dataDir, <span class="string">"app-asec"</span>).getPath();</span><br><span class="line">mUserAppDataDir = <span class="keyword">new</span> File(dataDir, <span class="string">"user"</span>);</span><br><span class="line">mDrmAppPrivateInstallDir = <span class="keyword">new</span> File(dataDir, <span class="string">"app-private"</span>);</span><br><span class="line"></span><br><span class="line">sUserManager = <span class="keyword">new</span> UserManagerService(context, <span class="keyword">this</span>,</span><br><span class="line">mInstallLock, mPackages);</span><br></pre></td></tr></table></figure>
<p>创建PackageHandler对象，建立PackageHandler的消息循环，用于处理apk的安装请求。</p>
<p>为”/data”目录下的子目录生成文件对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data&#10;/data/app&#10;/data/app-lib&#10;/data/user&#10;/data/app-private</span><br></pre></td></tr></table></figure>
<p>创建用户管理服务UserManagerService：</p>
<p>继续PMS构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Propagate permission configuration in to package manager.</span></span><br><span class="line">    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</span><br><span class="line">            = systemConfig.getPermissions();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;permConfig.size(); i++) &#123;</span><br><span class="line">        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</span><br><span class="line">        BasePermission bp = mSettings.mPermissions.get(perm.name);</span><br><span class="line">        <span class="keyword">if</span> (bp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bp = <span class="keyword">new</span> BasePermission(perm.name, <span class="string">"android"</span>, BasePermission.TYPE_BUILTIN);</span><br><span class="line">            mSettings.mPermissions.put(perm.name, bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm.gids != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bp.setGids(perm.gids, perm.perUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;libConfig.size(); i++) &#123;</span><br><span class="line">        mSharedLibraries.put(libConfig.keyAt(i),</span><br><span class="line">                <span class="keyword">new</span> SharedLibraryEntry(libConfig.valueAt(i), <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</span><br></pre></td></tr></table></figure>
<p>作用是将前面从/system/etc/permission里面读取到的permission的name和对应的gid放入到bp中,然后保存在mSettings的mPermissions中.</p>
<p>也要把从/system/etc/permission中读取到的shared library 放到PMS的变量mSharedLibraries中去。</p>
<p>继续</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mRestoredSettings = mSettings.readLPw(<span class="keyword">this</span>, sUserManager.getUsers(<span class="keyword">false</span>),</span><br><span class="line">        mSdkVersion, mOnlyCore);</span><br><span class="line"></span><br><span class="line">String customResolverActivity = Resources.getSystem().getString(</span><br><span class="line">        R.string.config_customResolverActivity);</span><br><span class="line"><span class="keyword">if</span> (TextUtils.isEmpty(customResolverActivity)) &#123;</span><br><span class="line">    customResolverActivity = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mCustomResolverComponentName = ComponentName.unflattenFromString(</span><br><span class="line">            customResolverActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先调用Settings的readLPw函数去解析packages.xml和packages-backup.xml保存的安装列表信息，并把解析的pakcages信息添加到相应的数据结构中。</p>
<p>这里我们先假设这是Android设备第一次开机，所有packages.xml和packages-backup.xml文件都还不存在。所以Settings的readLPw函数会直接返回。</p>
<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startTime = SystemClock.uptimeMillis(); <span class="comment">// 获取当前时间</span></span><br><span class="line"></span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">       startTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set flag to monitor and not change apk file paths when</span></span><br><span class="line"><span class="comment">// scanning install directories.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;<span class="comment">//设置扫描模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ArraySet&lt;String&gt; alreadyDexOpted = <span class="keyword">new</span> ArraySet&lt;String&gt;();<span class="comment">// 存储已经优化的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Add everything in the in the boot class path to the</span><br><span class="line">* list of process files because dexopt will have been run</span><br><span class="line">* if necessary during zygote startup.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">final</span> String bootClassPath = System.getenv(<span class="string">"BOOTCLASSPATH"</span>);<span class="comment">//获取BOOTCLASSPATH环境变量的值</span></span><br><span class="line"><span class="keyword">final</span> String systemServerClassPath = System.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);<span class="comment">//获取SYSTEMSERVERCLASSPATH环境变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bootClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">   String[] bootClassPathElements = splitString(bootClassPath, <span class="string">':'</span>);</span><br><span class="line">   <span class="keyword">for</span> (String element : bootClassPathElements) &#123;</span><br><span class="line">       alreadyDexOpted.add(element); <span class="comment">//将BOOTCLASSPATH中的指明的文件加入已经优化的文件列表中</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   Slog.w(TAG, <span class="string">"No BOOTCLASSPATH found!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (systemServerClassPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">   String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class="string">':'</span>);</span><br><span class="line">   <span class="keyword">for</span> (String element : systemServerClassPathElements) &#123;</span><br><span class="line">       alreadyDexOpted.add(element);<span class="comment">//将SYSTEMSERVERCLASSPATH中的文件加入已经优化的文件列表中</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   Slog.w(TAG, <span class="string">"No SYSTEMSERVERCLASSPATH found!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该段代码主要是把BOOTCLASSPATH和SYSTEMSERVERCLASSPATH里面的文件添加到alreadyDexOpted这个HashSet中，因为它们在zygote启动时已经进过Dex优化了。</p>
<p>继续</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</span><br><span class="line"><span class="keyword">final</span> String[] dexCodeInstructionSets =</span><br><span class="line">        getDexCodeInstructionSets(</span><br><span class="line">                allInstructionSets.toArray(<span class="keyword">new</span> String[allInstructionSets.size()]));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Ensure all external libraries have had dexopt run on them.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">if</span> (mSharedLibraries.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> For now, we're compiling these system "shared libraries"</span></span><br><span class="line">    <span class="comment">// (and framework jars) into all available architectures. It's possible</span></span><br><span class="line">    <span class="comment">// to compile them only when we come across an app that uses them (there's</span></span><br><span class="line">    <span class="comment">// already logic for that in scanPackageLI) but that adds some complexity.</span></span><br><span class="line">    <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String lib = libEntry.path;</span><br><span class="line">            <span class="keyword">if</span> (lib == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> dexoptNeeded = DexFile.getDexOptNeeded(lib, <span class="keyword">null</span>, dexCodeInstructionSet, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                    alreadyDexOpted.add(lib);</span><br><span class="line">                    mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class="keyword">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Library not found: "</span> + lib);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Cannot dexopt "</span> + lib + <span class="string">"; is it an APK or JAR? "</span></span><br><span class="line">                        + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先获取当前Android设备的abi列表，也就是armeabi,armeabi-v7a,arm64-v8a等等信息。</p>
<p>然后在每种abi情况下，利用DexFile.getDexOptNeeded检查该library是否已经执行过dexopt了。</p>
<p>NO_DEXOPT_NEEDED ：if the apk/jar is already up to date.</p>
<p>DEX2OAT_NEEDED： if dex2oat should be called on the apk/jar file.</p>
<p>PATCHOAT_NEEDED：if patchoat should be called on the apk/jar file to patch the odex file along side the apk/jar.</p>
<p>SELF_PATCHOAT_NEEDED if selfpatchoat should be called on the apk/jar file to patch the oat file in the dalvik cache.</p>
<p>当结果不为NO_DEXOPT_NEEDED表明，该library需要dexopt.通过mInstaller的dexopt进行dexopt操作。</p>
<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">File frameworkDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"framework"</span>);<span class="comment">//"/system/framework"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Gross hack for now: we know this file doesn't contain any</span></span><br><span class="line"><span class="comment">// code, so don't dexopt it to avoid the resulting log spew.</span></span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/framework-res.apk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gross hack for now: we know this file is only part of</span></span><br><span class="line"><span class="comment">// the boot class path for art, so don't dexopt it to</span></span><br><span class="line"><span class="comment">// avoid the resulting log spew.</span></span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/core-libart.jar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * There are a number of commands implemented in Java, which</span><br><span class="line"> * we currently need to do the dexopt on so that they can be</span><br><span class="line"> * run from a non-root shell.</span><br><span class="line"> */</span></span><br><span class="line">String[] frameworkFiles = frameworkDir.list();</span><br><span class="line"><span class="keyword">if</span> (frameworkFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We could compile these only for the most preferred ABI. We should</span></span><br><span class="line">    <span class="comment">// first double check that the dex files for these commands are not referenced</span></span><br><span class="line">    <span class="comment">// by other system apps.</span></span><br><span class="line">    <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;frameworkFiles.length; i++) &#123;</span><br><span class="line">            File libPath = <span class="keyword">new</span> File(frameworkDir, frameworkFiles[i]);</span><br><span class="line">            String path = libPath.getPath();</span><br><span class="line">            <span class="comment">// Skip the file if we already did it.</span></span><br><span class="line">            <span class="keyword">if</span> (alreadyDexOpted.contains(path)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Skip the file if it is not a type we want to dexopt.</span></span><br><span class="line">            <span class="keyword">if</span> (!path.endsWith(<span class="string">".apk"</span>) &amp;&amp; !path.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//跳过那些非apk和jar的文件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> dexoptNeeded = DexFile.getDexOptNeeded(path, <span class="keyword">null</span>, dexCodeInstructionSet, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                    mInstaller.dexopt(path, Process.SYSTEM_UID, <span class="keyword">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Jar not found: "</span> + path);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception reading jar: "</span> + path, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/system/framework/framework-res.apk&#10;/system/framework/core-libart.jar</span><br></pre></td></tr></table></figure>
<p>这两个文件加入已优化列表alreadyDexOpted中去。</p>
<p>然后搜索/system/framework中那些还没有dexopt的jar或者apk文件，进行dexopt操作。</p>
<p>继续：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inal VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line"><span class="comment">// when upgrading from pre-M, promote system app permissions from install to runtime</span></span><br><span class="line">mPromoteSystemApps =</span><br><span class="line">        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save off the names of pre-existing system packages prior to scanning; we don't</span></span><br><span class="line"><span class="comment">// want to automatically grant runtime permissions for new system apps</span></span><br><span class="line"><span class="keyword">if</span> (mPromoteSystemApps) &#123;</span><br><span class="line">    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">    <span class="keyword">while</span> (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">        PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">        <span class="keyword">if</span> (isSystemApp(ps)) &#123;</span><br><span class="line">            mExistingSystemPackages.add(ps.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是升级系统时，进行的处理，假设没有进行系统升级，则忽略这段代码。</p>
<p>在接下来的处理中，就会遇到PMS的一个非常重要的函数：scanDirLI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collect vendor overlay packages.</span></span><br><span class="line"><span class="comment">// (Do this before scanning any apps.)</span></span><br><span class="line"><span class="comment">// For security and version matching reason, only consider</span></span><br><span class="line"><span class="comment">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></span><br><span class="line">File vendorOverlayDir = <span class="keyword">new</span> File(VENDOR_OVERLAY_DIR);</span><br><span class="line">scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find base frameworks (resource packages without code).</span></span><br><span class="line">scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">        | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line">        scanFlags | SCAN_NO_DEX, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collected privileged system packages.</span></span><br><span class="line"><span class="keyword">final</span> File privilegedAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"priv-app"</span>);</span><br><span class="line">scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collect ordinary system packages.</span></span><br><span class="line"><span class="keyword">final</span> File systemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"app"</span>);</span><br><span class="line">scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collect all vendor packages.</span></span><br><span class="line">File vendorAppDir = <span class="keyword">new</span> File(<span class="string">"/vendor/app"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">&#125;</span><br><span class="line">scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collect all OEM packages.</span></span><br><span class="line"><span class="keyword">final</span> File oemAppDir = <span class="keyword">new</span> File(Environment.getOemDirectory(), <span class="string">"app"</span>);</span><br><span class="line">scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>依次调用scanDirLI方法对下列的目录中的apk文件进行扫描。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vendor/overlay&#10;/system/framework&#10;/system/priv-app&#10;/system/app&#10;/vendor/app&#10;/oem/app</span><br></pre></td></tr></table></figure></p>
<p>scanDirLI方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File dir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No files in app dir "</span> + dir);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 会从传入的dir中，遍历所有的文件，如果没有文件，则直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Scanning app dir "</span> + dir + <span class="string">" scanFlags="</span> + scanFlags</span><br><span class="line">                    + <span class="string">" flags=0x"</span> + Integer.toHexString(parseFlags));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;<span class="comment">// 如果有文件存在的话，就会进行遍历</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断一个文件是否是一个apk的文件（以apk结尾），或者是一个文件夹并且文件夹满足isStageName的条件</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">                    &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">            <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">                <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 会调用scanPackageLI进行接下来的解析</span></span><br><span class="line">                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</span><br><span class="line">                        scanFlags, currentTime, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed to parse "</span> + file + <span class="string">": "</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Delete invalid userdata apps</span></span><br><span class="line">                <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">                    <span class="comment">// 只有非系统的apk扫描失败的时候，才会删除该apk。</span></span><br><span class="line">                    logCriticalInfo(Log.WARN, <span class="string">"Deleting invalid package at "</span> + file);</span><br><span class="line">                    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                        mInstaller.rmPackageDir(file.getAbsolutePath());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStageName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isFile = name.startsWith(<span class="string">"vmdl"</span>) &amp;&amp; name.endsWith(<span class="string">".tmp"</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isContainer = name.startsWith(<span class="string">"smdl"</span>) &amp;&amp; name.endsWith(<span class="string">".tmp"</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> isLegacyContainer = name.startsWith(<span class="string">"smdl2tmp"</span>);</span><br><span class="line">         <span class="keyword">return</span> isFile || isContainer || isLegacyContainer;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>找到apk文件后，会调用scanPackageLI来解析该文件，并将该apk转换为PackageParser.Package对象。</p>
<p>源码位置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android-6.0/framworks/base/core/java/android/content/pm/PackageParser.java</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Package</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String packageName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Names of any split APKs, ordered by parsed splitName */</span></span><br><span class="line">        <span class="keyword">public</span> String[] splitNames;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> work towards making these paths invariant</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String volumeUuid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Path where this package was found on disk. For monolithic packages</span><br><span class="line">         * this is path to single base APK file; for cluster packages this is</span><br><span class="line">         * path to the cluster directory.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> String codePath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Path of base APK */</span></span><br><span class="line">        <span class="keyword">public</span> String baseCodePath;</span><br><span class="line">        <span class="comment">/** Paths of any split APKs, ordered by parsed splitName */</span></span><br><span class="line">        <span class="keyword">public</span> String[] splitCodePaths;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Revision code of base APK */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> baseRevisionCode;</span><br><span class="line">        <span class="comment">/** Revision codes of any split APKs, ordered by parsed splitName */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] splitRevisionCodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Flags of any split APKs; ordered by parsed splitName */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] splitFlags;</span><br><span class="line">        ...............................</span><br></pre></td></tr></table></figure>
<p>PackageParser.Package是一个apk文件在PMS中的代表，利用pm命令获得apk的信息，就是通过该类表示的。里面记录了apk的包名等信息。</p>
<p>scanPackageLI的代码量也是很大，所以也分段解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span><br><span class="line">            <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, <span class="string">"Parsing: "</span> + scanFile);</span><br><span class="line">        parseFlags |= mDefParseFlags;</span><br><span class="line">        PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">        pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">        pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">        pp.setDisplayMetrics(mMetrics);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != <span class="number">0</span>) &#123;</span><br><span class="line">            parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PackageParser.Package pkg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pkg = pp.parsePackage(scanFile, parseFlags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> PackageManagerException.from(e);</span><br><span class="line">        &#125;</span><br><span class="line">.................</span><br></pre></td></tr></table></figure>
<p>scanPackageLI创建了一个文件解析器PackageParser，然后调用的解析器的parsePackage方法解析。</p>
<p>继续scanPackageLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PackageSetting ps = <span class="keyword">null</span>;</span><br><span class="line">PackageSetting updatedPkg;</span><br><span class="line"><span class="comment">// reader</span></span><br><span class="line"><span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">    <span class="comment">// Look to see if we already know about this package.</span></span><br><span class="line">    String oldName = mSettings.mRenamedPackages.get(pkg.packageName);</span><br><span class="line">    <span class="keyword">if</span> (pkg.mOriginalPackages != <span class="keyword">null</span> &amp;&amp; pkg.mOriginalPackages.contains(oldName)) &#123;</span><br><span class="line">        <span class="comment">// This package has been renamed to its original name.  Let's</span></span><br><span class="line">        <span class="comment">// use that.</span></span><br><span class="line">        ps = mSettings.peekPackageLPr(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there was no original package, see one for the real package name.</span></span><br><span class="line">    <span class="keyword">if</span> (ps == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//这里当设备不是第一次开机时，会解析packages.xml，将里面记录的pacakge都存储到mSettings的mPackages中，它是一个ArrayMap&lt;String, PackageSetting&gt;变量。</span></span><br><span class="line">      <span class="comment">//以扫描到的包名检测是否已经存在ps了，PackageSetting:Settings data for a particular package we know about.</span></span><br><span class="line">        ps = mSettings.peekPackageLPr(pkg.packageName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是处理应用升级后包名不一致的情况，当设备第一次开机时，不存在这样的情况。其他情况下，开机会解析packages.xml，当前后有apk的包名发生变化时，该app在packages.xml中会以<renamed-package>标签标记。<br>而且还会把这些包名更改了的信息计入 PMS的mSettings变量的ArrayMap<string, string=""> 类型的变量mRenamedPackages中，key是newname.</string,></renamed-package></p>
<p>继续scanPackageLI：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Check to see if this package could be hiding/updating a system</span></span><br><span class="line">    <span class="comment">// package.  Must look for it either under the original or real</span></span><br><span class="line">    <span class="comment">// package name depending on our state.</span></span><br><span class="line">    updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != <span class="keyword">null</span> ? ps.name : pkg.packageName);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTALL &amp;&amp; updatedPkg != <span class="keyword">null</span>) Slog.d(TAG, <span class="string">"updatedPkg = "</span> + updatedPkg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> updatedPkgBetter = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// First check if this is a system package that may involve an update</span></span><br><span class="line"><span class="keyword">if</span> (updatedPkg != <span class="keyword">null</span> &amp;&amp; (parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If new package is not located in "/system/priv-app" (e.g. due to an OTA),</span></span><br><span class="line">    <span class="comment">// it needs to drop FLAG_PRIVILEGED.</span></span><br><span class="line">    <span class="keyword">if</span> (locationIsPrivileged(scanFile)) &#123;</span><br><span class="line">        updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updatedPkg.pkgPrivateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; !ps.codePath.equals(scanFile)) &#123;</span><br><span class="line">        <span class="comment">// The path has changed from what was last scanned...  check the</span></span><br><span class="line">        <span class="comment">// version of the new path against what we have stored to determine</span></span><br><span class="line">        <span class="comment">// what to do.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INSTALL) Slog.d(TAG, <span class="string">"Path changing from "</span> + ps.codePath);</span><br><span class="line">        <span class="keyword">if</span> (pkg.mVersionCode &lt;= ps.versionCode) &#123;</span><br><span class="line">            <span class="comment">// The system package has been updated and the code path does not match</span></span><br><span class="line">            <span class="comment">// Ignore entry. Skip it.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">"Package "</span> + ps.name + <span class="string">" at "</span> + scanFile</span><br><span class="line">                    + <span class="string">" ignored: updated version "</span> + ps.versionCode</span><br><span class="line">                    + <span class="string">" better than this "</span> + pkg.mVersionCode);</span><br><span class="line">            <span class="keyword">if</span> (!updatedPkg.codePath.equals(scanFile)) &#123;</span><br><span class="line">                Slog.w(PackageManagerService.TAG, <span class="string">"Code path for hidden system pkg : "</span></span><br><span class="line">                        + ps.name + <span class="string">" changing from "</span> + updatedPkg.codePathString</span><br><span class="line">                        + <span class="string">" to "</span> + scanFile);</span><br><span class="line">                updatedPkg.codePath = scanFile;</span><br><span class="line">                updatedPkg.codePathString = scanFile.toString();</span><br><span class="line">                updatedPkg.resourcePath = scanFile;</span><br><span class="line">                updatedPkg.resourcePathString = scanFile.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            updatedPkg.pkg = pkg;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,</span><br><span class="line">                    <span class="string">"Package "</span> + ps.name + <span class="string">" at "</span> + scanFile</span><br><span class="line">                            + <span class="string">" ignored: updated version "</span> + ps.versionCode</span><br><span class="line">                            + <span class="string">" better than this "</span> + pkg.mVersionCode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The current app on the system partition is better than</span></span><br><span class="line">            <span class="comment">// what we have updated to on the data partition; switch</span></span><br><span class="line">            <span class="comment">// back to the system partition version.</span></span><br><span class="line">            <span class="comment">// At this point, its safely assumed that package installation for</span></span><br><span class="line">            <span class="comment">// apps in system partition will go through. If not there won't be a working</span></span><br><span class="line">            <span class="comment">// version of the app</span></span><br><span class="line">            <span class="comment">// writer</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">                <span class="comment">// Just remove the loaded entries from package lists.</span></span><br><span class="line">                mPackages.remove(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logCriticalInfo(Log.WARN, <span class="string">"Package "</span> + ps.name + <span class="string">" at "</span> + scanFile</span><br><span class="line">                    + <span class="string">" reverting from "</span> + ps.codePathString</span><br><span class="line">                    + <span class="string">": new version "</span> + pkg.mVersionCode</span><br><span class="line">                    + <span class="string">" better than installed "</span> + ps.versionCode);</span><br><span class="line"></span><br><span class="line">            InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),</span><br><span class="line">                    ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));</span><br><span class="line">            <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                args.cleanUpResourcesLI();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">                mSettings.enableSystemPackageLPw(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">            updatedPkgBetter = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (updatedPkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// An updated system app will not have the PARSE_IS_SYSTEM flag set</span></span><br><span class="line">    <span class="comment">// initially</span></span><br><span class="line">    parseFlags |= PackageParser.PARSE_IS_SYSTEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An updated privileged app will not have the PARSE_IS_PRIVILEGED</span></span><br><span class="line">    <span class="comment">// flag set initially</span></span><br><span class="line">    <span class="keyword">if</span> ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != <span class="number">0</span>) &#123;</span><br><span class="line">        parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是处理安装了系统更新后的，检查是否对系统app有影响。即是否将系统app更新为更高的新版本了。是的话，要处理。</p>
<p>接下来是扫描apk的签名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verify certificates against what was last scanned</span></span><br><span class="line">collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);</span><br></pre></td></tr></table></figure>
<p>继续scanPackageLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * A new system app appeared, but we already had a non-system one of the</span><br><span class="line"> * same name installed earlier.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">boolean</span> shouldHideSystemApp = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (updatedPkg == <span class="keyword">null</span> &amp;&amp; ps != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (parseFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != <span class="number">0</span> &amp;&amp; !isSystemApp(ps)) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Check to make sure the signatures match first. If they don't,</span><br><span class="line">     * wipe the installed application and its data.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)</span><br><span class="line">            != PackageManager.SIGNATURE_MATCH) &#123;</span><br><span class="line">        logCriticalInfo(Log.WARN, <span class="string">"Package "</span> + ps.name + <span class="string">" appeared on system, but"</span></span><br><span class="line">                + <span class="string">" signatures don't match existing userdata copy; removing"</span>);</span><br><span class="line">        deletePackageLI(pkg.packageName, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        ps = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * If the newly-added system app is an older version than the</span><br><span class="line">         * already installed version, hide it. It will be scanned later</span><br><span class="line">         * and re-added like an update.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pkg.mVersionCode &lt;= ps.versionCode) &#123;</span><br><span class="line">            shouldHideSystemApp = <span class="keyword">true</span>;</span><br><span class="line">            logCriticalInfo(Log.INFO, <span class="string">"Package "</span> + ps.name + <span class="string">" appeared at "</span> + scanFile</span><br><span class="line">                    + <span class="string">" but new version "</span> + pkg.mVersionCode + <span class="string">" better than installed "</span></span><br><span class="line">                    + ps.versionCode + <span class="string">"; hiding system"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * The newly found system app is a newer version that the</span><br><span class="line">             * one previously installed. Simply remove the</span><br><span class="line">             * already-installed application and replace it with our own</span><br><span class="line">             * while keeping the application data.</span><br><span class="line">             */</span></span><br><span class="line">            logCriticalInfo(Log.WARN, <span class="string">"Package "</span> + ps.name + <span class="string">" at "</span> + scanFile</span><br><span class="line">                    + <span class="string">" reverting from "</span> + ps.codePathString + <span class="string">": new version "</span></span><br><span class="line">                    + pkg.mVersionCode + <span class="string">" better than installed "</span> + ps.versionCode);</span><br><span class="line">            InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),</span><br><span class="line">                    ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));</span><br><span class="line">            <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                args.cleanUpResourcesLI();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码是处理这样的情景：当系统更新后，可能更新包会多出一些system app出来，那么如果此时用户恰好安装了一个同包名的app.两者的签名还不一致，那么就删除扫描到的系统应用的信息。</p>
<p>当两者签名一致时，如果扫描到的app版本更高，那么就删除安装的应用；如果扫描的app版本低，那么隐藏扫描到的系统应用。</p>
<p>继续scanPackageLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The apk is forward locked (not public) if its code and resources</span></span><br><span class="line"><span class="comment">// are kept in different files. (except for app in either system or</span></span><br><span class="line"><span class="comment">// vendor path).</span></span><br><span class="line"><span class="comment">// TODO grab this value from PackageSettings</span></span><br><span class="line"><span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; !ps.codePath.equals(ps.resourcePath)) &#123;</span><br><span class="line">        parseFlags |= PackageParser.PARSE_FORWARD_LOCK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> extend to support forward-locked splits</span></span><br><span class="line">String resourcePath = <span class="keyword">null</span>;</span><br><span class="line">String baseResourcePath = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != <span class="number">0</span> &amp;&amp; !updatedPkgBetter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; ps.resourcePathString != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resourcePath = ps.resourcePathString;</span><br><span class="line">        baseResourcePath = ps.resourcePathString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Should not happen at all. Just log an error.</span></span><br><span class="line">        Slog.e(TAG, <span class="string">"Resource path not set for pkg : "</span> + pkg.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resourcePath = pkg.codePath;</span><br><span class="line">    baseResourcePath = pkg.baseCodePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set application objects path explicitly.</span></span><br><span class="line">pkg.applicationInfo.volumeUuid = pkg.volumeUuid;</span><br><span class="line">pkg.applicationInfo.setCodePath(pkg.codePath);</span><br><span class="line">pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);</span><br><span class="line">pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);</span><br><span class="line">pkg.applicationInfo.setResourcePath(resourcePath);</span><br><span class="line">pkg.applicationInfo.setBaseResourcePath(baseResourcePath);</span><br><span class="line">pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);</span><br></pre></td></tr></table></figure>
<p>处理应用的代码路径和资源路径。</p>
<p>继续scanPackageLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that we invoke the following method only if we are about to unpack an application</span></span><br><span class="line">PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line">        | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br></pre></td></tr></table></figure>
<p>调用PackageParser的另一个scanPackageLI继续处理，后续会对其分析。</p>
<p>继续scanPackageLI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span><br><span class="line">     * If the system app should be overridden by a previously installed</span><br><span class="line">     * data, hide the system app now and let the /data/app scan pick it up</span><br><span class="line">     * again.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (shouldHideSystemApp) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            mSettings.disableSystemPackageLPw(pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scannedPkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果扫描的系统app需要被隐藏，那么通过mSettings.disableSystemPackageLPw方法将其信息记录在mSettings的mDisabledSysPackages中。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/21/Android_PackageManagerService-5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Android-6.0之PMS解析中篇2
        
      </div>
    </a>
  
  
    <a href="/2016/06/21/Android_PackageManagerService-3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android-6.0之PMS解析上篇</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Android_PackageManagerService-4" data-title="Android-6.0之PMS解析中篇1" data-url="http://www.iloveandroid.net/2016/06/21/Android_PackageManagerService-4/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"iloveandroid"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 genglei.cuan
   <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256335558'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256335558%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script> 
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>